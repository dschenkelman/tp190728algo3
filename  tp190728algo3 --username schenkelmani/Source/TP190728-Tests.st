TestCase subclass: #EstrategiaDerivacionTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaDerivacionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 13:13'!testEstrategiaDerivacionDerivaLogartimoCorrectamente	| funcion estrategia |	funcion := MockFuncion new.	funcion formaEvaluacion: [	:x| x log: Float e	].	estrategia := EstrategiaDerivacion crearNueva.	self assert:((estrategia derivar:funcion en: 1) closeTo: 1).	self assert:((estrategia derivar:funcion en: 2) closeTo: 1/2).	self assert:((estrategia derivar:funcion en: 4) closeTo: 1/4).	self assert:((estrategia derivar:funcion en: 1000000000) closeTo: 0).	self assert:((estrategia derivar:funcion en: -1) isNaN).! !!EstrategiaDerivacionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 13:00'!testEstrategiaDerivacionDerivaSenoXCorrectamente	| funcion estrategia |	funcion := MockFuncion new.	funcion formaEvaluacion: [:x| x sin].	estrategia := EstrategiaDerivacion crearNueva.	self assert:((estrategia derivar:funcion en: 0) = 1).	self assert:((estrategia derivar:funcion en: Float pi / 2) closeTo: 0).	self assert:((estrategia derivar:funcion en: Float pi / 4) closeTo: ((2 raisedTo: 0.5)/2)).	self assert:((estrategia derivar:funcion en: Float pi) closeTo: -1).	self assert:((estrategia derivar:funcion en: Float pi * (3/2)) closeTo: 0).! !!EstrategiaDerivacionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 12:31'!testEstrategiaDerivacionDerivaXCorrectamente	| funcion estrategia |	funcion := MockFuncion new.	funcion formaEvaluacion: [:x| x].	estrategia := EstrategiaDerivacion crearNueva.	self assert:((estrategia derivar:funcion en: 0) = 1).	self assert:((estrategia derivar:funcion en: 1) closeTo: 1).	self assert:((estrategia derivar:funcion en: -1) closeTo: 1).! !!EstrategiaDerivacionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 12:32'!testEstrategiaDerivacionDerivaXCuadradoCorrectamente	| funcion estrategia |	funcion := MockFuncion new.	funcion formaEvaluacion: [:x| x raisedToInteger: 2].	estrategia := EstrategiaDerivacion crearNueva.	self assert:((estrategia derivar:funcion en: 0) closeTo: 0).	self assert:((estrategia derivar:funcion en: 1) closeTo: 2).	self assert:((estrategia derivar:funcion en: -1) closeTo: -2).	self assert:((estrategia derivar:funcion en: 2) closeTo: 4).	self assert:((estrategia derivar:funcion en: -2) closeTo: -4).! !!EstrategiaDerivacionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 12:32'!testPuedeSetearDiferencialXSoloUnaVez	| funcion estrategia |	funcion := MockFuncion new.	funcion formaEvaluacion: [:x| x].	estrategia := EstrategiaDerivacion crearNueva.	self should: [estrategia setDiferencialX: 0.1] raise: Error.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaDerivacionTestCase class	instanceVariableNames: ''!!EstrategiaDerivacionTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 12:35'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionArcoCosenoTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionArcoCosenoTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:24'!testCrearEstrategiaDevuelveEstrategiaNoNula	| funcion estrategia |	funcion := MockFuncion new.	estrategia := EstrategiaEvaluacionArcoCoseno crearNueva: funcion.	self deny: (estrategia == nil).! !!EstrategiaEvaluacionArcoCosenoTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 17:28'!testEvaluarArcoCosenoEnValorDevuelveValorCorrecto	| bloque funcion estrategia resultado |	bloque := [:x| x - ((2 raisedTo: 0.5) / 2)].	funcion := MockFuncion new.	funcion formaEvaluacion: bloque.	estrategia := EstrategiaEvaluacionArcoCoseno crearNueva: funcion.	resultado := estrategia evaluarEn:((2 raisedTo: 0.5) / 2).	self assert: (resultado =  (Float pi / 2) )! !!EstrategiaEvaluacionArcoCosenoTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 17:22'!testEvaluarFueraDelDominioLanzaExcepcion	| bloque funcion estrategia resultado |	bloque := [:x| x].	funcion := MockFuncion new.	funcion formaEvaluacion: bloque.	estrategia := EstrategiaEvaluacionArcoCoseno crearNueva: funcion.	self should: [estrategia evaluarEn: 2] raise: ExcepcionDominioFuncion.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionArcoCosenoTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionArcoCosenoTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:18'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionArcoSenoTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionArcoSenoTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:24'!testCrearEstrategiaDevuelveEstrategiaNoNula	| funcion estrategia |	funcion := MockFuncion new.	estrategia := EstrategiaEvaluacionArcoSeno crearNueva: funcion.	self deny: (estrategia == nil).! !!EstrategiaEvaluacionArcoSenoTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 17:09'!testEvaluarArcoSenoEnValorDevuelveValorCorrecto	| bloque funcion estrategia resultado |	bloque := [:x| x].	funcion := MockFuncion new.	funcion formaEvaluacion: bloque.	estrategia := EstrategiaEvaluacionArcoSeno crearNueva: funcion.	resultado := estrategia evaluarEn:((2 raisedTo: 0.5) / 2).	self assert: (resultado =  (Float pi / 4) )! !!EstrategiaEvaluacionArcoSenoTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 17:21'!testEvaluarFueraDelDominioLanzaExcepcion	| bloque funcion estrategia resultado |	bloque := [:x| x].	funcion := MockFuncion new.	funcion formaEvaluacion: bloque.	estrategia := EstrategiaEvaluacionArcoSeno crearNueva: funcion.	self should: [estrategia evaluarEn: 2] raise: ExcepcionDominioFuncion.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionArcoSenoTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionArcoSenoTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:18'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionConstantesTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionConstantesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:06'!testCrearEstrategiaDevuelveEstrategiaNoNula 	| estrategia |	estrategia := EstrategiaEvaluacionConstantes crearNueva: 5.	self deny: (estrategia == nil).	! !!EstrategiaEvaluacionConstantesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/10/2010 12:54'!testEvaluarEnValorDevuelveConstante	| estrategia evalCinco evalDos |	estrategia := EstrategiaEvaluacionConstantes crearNueva: 2.	evalCinco := estrategia evaluarEn: 5.	evalDos := estrategia evaluarEn: 2.	self assert: (evalCinco = 2).	self assert: (evalDos = 2).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionConstantesTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionConstantesTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:18'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionCosenoTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionCosenoTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:24'!testCrearEstrategiaDevuelveEstrategiaNoNula	| funcion estrategia |	funcion := MockFuncion new.	estrategia := EstrategiaEvaluacionCoseno crearNueva: funcion.	self deny: (estrategia == nil).	! !!EstrategiaEvaluacionCosenoTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 01:05'!testEvaluarCosenoEnValorDevuelveValorCorrecto	| bloque funcion estrategia resultado |	bloque := [:x| x + (Float pi /2)].	funcion := MockFuncion new.	funcion formaEvaluacion: bloque.	estrategia := EstrategiaEvaluacionCoseno crearNueva: funcion.	resultado := estrategia evaluarEn: Float pi * 7/2.	self assert: (resultado =  1)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionCosenoTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionCosenoTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:18'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionDivisionTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionDivisionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:04'!testCrearEstrategiaDevuelveEstrategiaNoNula	| numerador denominador estrategia |	numerador := MockFuncion new.	denominador := MockFuncion new.	estrategia := EstrategiaEvaluacionDivision crearNuevaCon: numerador y: denominador.	self deny: (estrategia == nil).! !!EstrategiaEvaluacionDivisionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/10/2010 20:03'!testDividirConDivisorCeroLanzaZeroDivide	| bloqueUno bloqueDos numerador denominador estrategia |	bloqueUno := ([:x | (x - 1) raisedToInteger: 3]).	bloqueDos := ([:x | (x + 1) raisedTo: 2 ]).	numerador := MockFuncion new.	numerador formaEvaluacion: bloqueUno.	denominador := MockFuncion new.	denominador  formaEvaluacion: bloqueDos.	estrategia := EstrategiaEvaluacionDivision crearNuevaCon: numerador  y: denominador.	self should: [estrategia evaluarEn: -1] raise: ZeroDivide.! !!EstrategiaEvaluacionDivisionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/10/2010 17:11'!testDividirFuncionesDivideCorrectamente	| resultado bloqueUno bloqueDos numerador denominador estrategia |		bloqueUno := ([:x | (x - 1) raisedToInteger: 3]).	bloqueDos := ([:x | (x + 1) raisedTo: 2 ]).	numerador := MockFuncion new.	numerador formaEvaluacion: bloqueUno.	denominador := MockFuncion new.	denominador  formaEvaluacion: bloqueDos.	estrategia := EstrategiaEvaluacionDivision crearNuevaCon: numerador  y: denominador.	resultado :=	estrategia evaluarEn:8.	self	assert: (resultado = (343/81)).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionDivisionTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionDivisionTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:19'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionExponencialTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionExponencialTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:05'!testCrearEstrategiaDevuelveEstrategiaNoNula	| base exponente estrategia |	base := MockFuncion new.	exponente := MockFuncion new.	estrategia := EstrategiaEvaluacionExponencial crearNuevaCon: base y: exponente.	self deny: (estrategia == nil).! !!EstrategiaEvaluacionExponencialTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/10/2010 19:29'!testEvaluarEnValorConBaseConstanteDevuelveValorCorrecto 	| temporary variable names bloqueUno bloqueDos base exponente estrategia resultado |	bloqueUno := ([:x | 2]).	bloqueDos := ([:x | (x) raisedToInteger: 2]).	base := MockFuncion new.	base formaEvaluacion: bloqueUno.	exponente := MockFuncion new.	exponente  formaEvaluacion: bloqueDos.	estrategia := EstrategiaEvaluacionExponencial  crearNuevaCon: base  y: exponente.	resultado :=	estrategia evaluarEn:3.	self	assert: (resultado = 512).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionExponencialTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionExponencialTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:19'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionFactorialTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionFactorialTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:24'!testCrearEstrategiaDevuelveEstrategiaNoNula	|funcion estrategia|	funcion  := MockFuncion new.	estrategia := EstrategiaEvaluacionFactorial crearNueva: funcion.	self	deny:  (estrategia == nil).! !!EstrategiaEvaluacionFactorialTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 15:17'!testEvaluarFactorialEnValorDevuelveValorCorrecto	| bloque funcion estrategia resultado resultadoDos |	bloque := [:x| x + 5].	funcion := MockFuncion new.	funcion formaEvaluacion: bloque.	estrategia := EstrategiaEvaluacionFactorial crearNueva: funcion.	resultado := estrategia evaluarEn: 1.	resultadoDos := estrategia evaluarEn: -5.	self assert: (resultado =  720).	self assert: (resultadoDos =  1).! !!EstrategiaEvaluacionFactorialTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 21:41'!testEvaluarFactorialEnValoresInvalidosLanzaExcepcion	| bloque funcion estrategia |	bloque := [:x| x].	funcion := MockFuncion new.	funcion formaEvaluacion: bloque.	estrategia := EstrategiaEvaluacionFactorial crearNueva: funcion.	self should: [estrategia evaluarEn: 1.1] raise: ExcepcionDominioFuncion. 	self should: [estrategia evaluarEn: -4] raise: ExcepcionDominioFuncion.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionFactorialTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionFactorialTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:19'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionFibonacciTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionFibonacciTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:25'!testCrearEstrategiaDevuelveEstrategiaNoNula	|funcion estrategia|	funcion  := MockFuncion new.	estrategia := EstrategiaEvaluacionFibonacci crearNueva: funcion.	self	deny:  (estrategia == nil).! !!EstrategiaEvaluacionFibonacciTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 16:58'!testEvaluarFactorialEnCeroDevuelveCero	| bloque funcion estrategia resultado |	bloque := [:x| x].	funcion := MockFuncion new.	funcion formaEvaluacion: bloque.	estrategia := EstrategiaEvaluacionFibonacci crearNueva: funcion.	resultado := estrategia evaluarEn: 0.	self assert: (resultado =  0).! !!EstrategiaEvaluacionFibonacciTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 16:58'!testEvaluarFactorialEnNumeroDevuelveValorCorrecto	| bloque funcion estrategia resultado resultadoDos resultadoTres |	bloque := [:x| x].	funcion := MockFuncion new.	funcion formaEvaluacion: bloque.	estrategia := EstrategiaEvaluacionFibonacci crearNueva: funcion.	resultado := estrategia evaluarEn: 16.	resultadoDos := estrategia evaluarEn: 8.	resultadoTres := estrategia evaluarEn: 3.	"http://en.wikipedia.org/wiki/Fibonacci_number"	self assert: (resultado =  987).	self assert: (resultadoDos =  21).	self assert: (resultadoTres =  2).! !!EstrategiaEvaluacionFibonacciTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 16:58'!testEvaluarFactorialEnUnoDevuelveUno	| bloque funcion estrategia resultado |	bloque := [:x| x].	funcion := MockFuncion new.	funcion formaEvaluacion: bloque.	estrategia := EstrategiaEvaluacionFibonacci crearNueva: funcion.	resultado := estrategia evaluarEn: 1.	self assert: (resultado =  1).! !!EstrategiaEvaluacionFibonacciTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 16:56'!testEvaluarFactorialEnValoresInvalidosLanzaExcepcion	| bloque funcion estrategia |	bloque := [:x| x].	funcion := MockFuncion new.	funcion formaEvaluacion: bloque.	estrategia := EstrategiaEvaluacionFibonacci crearNueva: funcion.	self should: [estrategia evaluarEn: 1.1] raise: ExcepcionDominioFuncion. 	self should: [estrategia evaluarEn: -4] raise: ExcepcionDominioFuncion.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionFibonacciTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionFibonacciTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:21'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionIntervalosContinuosTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionIntervalosContinuosTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/13/2010 00:55'!testEstrategiaEvaluacionIntervalosLanzaExcepcionSiLaFuncionNoEsEvaluableEnElIntervalo	| funcion estrategia valoresEvaluados |	funcion := MockFuncion new.	funcion formaEvaluacion: [:x | ExcepcionDominioFuncion new signal].	estrategia := EstrategiaEvaluacionIntervaloContinuo new.	self should: [estrategia evaluar:funcion desde: 1 hasta:4 cada:0.2] raise: ExcepcionEvaluacionIntervalo.	! !!EstrategiaEvaluacionIntervalosContinuosTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/12/2010 22:12'!testEvaluarEnIntervalosInvalidosLanzaExcepcion	| estrategia |	estrategia := EstrategiaEvaluacionIntervaloContinuo new.	"desde debe ser menor estricto que hasta"	self deny: (estrategia puedeEvaluarDesde: 2 hasta:1 cada:0.2).	self deny: (estrategia puedeEvaluarDesde: 2 hasta:2 cada:0.2).	"cada debe ser > 0"	self deny: (estrategia puedeEvaluarDesde: 1 hasta:7 cada:-5).	self deny: (estrategia puedeEvaluarDesde: 1 hasta:7 cada:0).	"hasta - desde > cada"	self deny: (estrategia puedeEvaluarDesde: 1 hasta:2 cada:4).! !!EstrategiaEvaluacionIntervalosContinuosTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/12/2010 22:12'!testEvaluarEnIntervalosValidosDevuelveTrue	| estrategia |	estrategia := EstrategiaEvaluacionIntervaloContinuo new.	self assert: (estrategia puedeEvaluarDesde: 1 hasta:2 cada:0.2).	self assert: (estrategia puedeEvaluarDesde: -2 hasta:4 cada:0.00001).! !!EstrategiaEvaluacionIntervalosContinuosTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/12/2010 22:27'!testEvaluarIntervaloDevuelveValoresDeEvaluacionCorrectos	| funcion estrategia valoresEvaluados |	funcion := MockFuncion new.	funcion formaEvaluacion: [:x | x].	estrategia := EstrategiaEvaluacionIntervaloContinuo new.	valoresEvaluados := estrategia evaluar:funcion desde: 1 hasta:4 cada:0.2.	1 to: 4 by: 0.2  do: 	[:x|		self assert: ((valoresEvaluados at: x) = x).	].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionIntervalosContinuosTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionIntervalosContinuosTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:21'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionIntervalosDiscretosTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionIntervalosDiscretosTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/13/2010 00:01'!testEvaluarEnIntervalosInvalidosLanzaExcepcion	| estrategia |	estrategia := EstrategiaEvaluacionIntervaloDiscreto new.	"desde debe ser menor estricto que hasta"	self deny: (estrategia puedeEvaluarDesde: 2 hasta:1 cada:0.2).	self deny: (estrategia puedeEvaluarDesde: 2 hasta:2 cada:0.2).	"cada debe ser > 0"	self deny: (estrategia puedeEvaluarDesde: 1 hasta:7 cada:-5).	self deny: (estrategia puedeEvaluarDesde: 1 hasta:7 cada:0).	"hasta - desde > cada"	self deny: (estrategia puedeEvaluarDesde: 1 hasta:2 cada:4).	"desde > 0"	self deny: (estrategia puedeEvaluarDesde: -1 hasta:6 cada:4).	"desde es entero"	self deny: (estrategia puedeEvaluarDesde: 1.1 hasta:6 cada:4).	"hasta es entero"	self deny: (estrategia puedeEvaluarDesde: 1 hasta:6.3 cada:4).	"cada es entero"	self deny: (estrategia puedeEvaluarDesde: 1 hasta:6 cada:4.2).! !!EstrategiaEvaluacionIntervalosDiscretosTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/12/2010 23:35'!testEvaluarIntervaloDevuelveValoresDeEvaluacionCorrectos	| funcion estrategia valoresEvaluados |	funcion := MockFuncion new.	funcion formaEvaluacion: [:x | x].	estrategia := EstrategiaEvaluacionIntervaloDiscreto new.	valoresEvaluados := estrategia evaluar:funcion desde: 1 hasta:8 cada:1.	1 to: 8 by: 1 do: 	[:x|		self assert: ((valoresEvaluados at: x) = x).	].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionIntervalosDiscretosTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionIntervalosDiscretosTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:21'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionLogaritmoNaturalTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionLogaritmoNaturalTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 16:49'!testCalcularLogaritmoNaturalFuncionaCorrectamente	| bloque funcion estrategia resultado |	bloque := ([:x | x raisedTo: 3]).	funcion := MockFuncion new.	funcion formaEvaluacion: bloque.	estrategia := EstrategiaEvaluacionLogaritmoNatural crearNueva: funcion.	resultado :=	estrategia evaluarEn: Float e.	self	assert: (resultado = 3).! !!EstrategiaEvaluacionLogaritmoNaturalTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:25'!testCrearEstrategiaDevuelveEstrategiaNoNula	| funcion estrategia |	funcion := MockFuncion new.	estrategia := EstrategiaEvaluacionLogaritmoNatural crearNueva: funcion.	self deny: (estrategia == nil).! !!EstrategiaEvaluacionLogaritmoNaturalTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 16:38'!testLogaritmoConArgumentoNegativoLanzaExcepcion	|  bloque funcion estrategia |	bloque := [:x | x-5 ].	funcion := MockFuncion new.	funcion formaEvaluacion: bloque.	estrategia := EstrategiaEvaluacionLogaritmoNatural crearNueva: funcion.	self should: [estrategia evaluarEn: 5] raise: ExcepcionDominioFuncion.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionLogaritmoNaturalTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionLogaritmoNaturalTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:21'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionMultiplicacionTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionMultiplicacionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:09'!testCrearEstrategiaDevuelveEstrategiaNoNula	| factorUno factorDos estrategia |	factorUno := MockFuncion new.	factorDos := MockFuncion new.	estrategia := EstrategiaEvaluacionMultiplicacion crearNuevaCon: factorUno y: factorDos.	self deny: (estrategia == nil).! !!EstrategiaEvaluacionMultiplicacionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/10/2010 17:32'!testMultiplicarFuncionesMultiplicaCorrectamente	| resultado bloqueUno bloqueDos factorUno factorDos estrategia |		bloqueUno := ([:x | x + 4]).	bloqueDos := ([:x | x raisedTo: 0.5 ]).	factorUno := MockFuncion new.	factorUno formaEvaluacion: bloqueUno.	factorDos := MockFuncion new.	factorDos  formaEvaluacion: bloqueDos.	estrategia := EstrategiaEvaluacionMultiplicacion crearNuevaCon: factorUno  y: factorDos.	resultado :=	estrategia evaluarEn:4.	self	assert: (resultado = 16).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionMultiplicacionTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionMultiplicacionTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:21'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionRestaTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionRestaTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:10'!testCrearEstrategiaDevuelveEstrategiaNoNula	| temporary variable names funcionInicial funcionARestar estrategia |	funcionInicial := MockFuncion new.	funcionARestar := MockFuncion new.	estrategia := EstrategiaEvaluacionResta crearNuevaCon: funcionInicial y: funcionARestar.	self deny: (estrategia == nil).! !!EstrategiaEvaluacionRestaTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/10/2010 16:28'!testRestarFuncionesRestaCorrectamente	| funcionInicial funcionARestar estrategia resultadoUno resultadoDos |	funcionInicial := MockFuncion new.	funcionInicial formaEvaluacion: [:x | (x cos) raisedToInteger: 2].	funcionARestar := MockFuncion new.	funcionARestar formaEvaluacion: [:x |  ((x sin) raisedToInteger: 2) * (-1)].	estrategia := EstrategiaEvaluacionResta crearNuevaCon: funcionInicial y: funcionARestar.	resultadoUno := estrategia evaluarEn: ((Float pi) /4).	resultadoDos := estrategia evaluarEn: ((Float pi) /6).	self	assert: (resultadoUno = 1).	self	assert: (resultadoDos = 1).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionRestaTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionRestaTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:21'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionSenoTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionSenoTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:23'!testCrearEstrategiaDevuelveEstrategiaNoNula	| funcion estrategia |	funcion := MockFuncion new.	estrategia := EstrategiaEvaluacionSeno crearNueva: funcion.	self deny: (estrategia == nil).	! !!EstrategiaEvaluacionSenoTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 00:41'!testEvaluarSenoEnValorDevuelveValorCorrecto	| bloque funcion estrategia resultado |	bloque := [:x| x + (Float pi /4)].	funcion := MockFuncion new.	funcion formaEvaluacion: bloque.	estrategia := EstrategiaEvaluacionSeno crearNueva: funcion.	resultado := estrategia evaluarEn: Float pi.	self assert: (resultado =  ((2 raisedTo: 0.5) / -2))! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionSenoTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionSenoTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:20'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionSumaTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionSumaTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:00'!testCrearEstrategiaDevuelveEstrategiaNoNula	|funcionUno funcionDos estrategia|	funcionUno  := MockFuncion new.	funcionDos  := MockFuncion new.	estrategia := EstrategiaEvaluacionSuma crearNuevaCon: funcionUno y: funcionDos. 	self	deny:  (estrategia == nil).! !!EstrategiaEvaluacionSumaTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/10/2010 15:47'!testSumarFuncionesSumaCorrectamente	| resultado bloqueUno bloqueDos funcionUno funcionDos estrategia |		bloqueUno := ([:x | x]).	bloqueDos := ([:x | x raisedToInteger: 3]).	funcionUno := MockFuncion new.	funcionUno formaEvaluacion: bloqueUno.	funcionDos := MockFuncion new.	funcionDos  formaEvaluacion: bloqueDos.	estrategia := EstrategiaEvaluacionSuma crearNuevaCon: funcionUno  y: funcionDos.	resultado :=	estrategia evaluarEn:3.	self	assert: (resultado = 30).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionSumaTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionSumaTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:20'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionTangenteTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionTangenteTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:23'!testCrearEstrategiaDevuelveEstrategiaNoNula	| funcion estrategia |	funcion := MockFuncion new.	estrategia := EstrategiaEvaluacionTangente crearNueva: funcion.	self deny: (estrategia == nil).! !!EstrategiaEvaluacionTangenteTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 01:37'!testEvaluarTangenteEnValorDevuelveValorCorrecto	| bloque funcion estrategia resultado |	bloque := [:x| x + (Float pi /2)].	funcion := MockFuncion new.	funcion formaEvaluacion: bloque.	estrategia := EstrategiaEvaluacionTangente crearNueva: funcion.	resultado := estrategia evaluarEn: Float pi / 2.	"Debido a cuestiones de redondeo no es igual a cero."	self assert: (resultado abs <  0.000000000001)! !!EstrategiaEvaluacionTangenteTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 16:21'!testEvaluarTangenteFueraDelDominioLanzaExcepcion	| bloque funcion estrategia |	bloque := [:x| x].	funcion := MockFuncion new.	funcion formaEvaluacion: bloque.	estrategia := EstrategiaEvaluacionTangente crearNueva: funcion.	self should: [estrategia evaluarEn: Float pi / 2] raise: ExcepcionDominioFuncion. 	self should: [estrategia evaluarEn: Float pi * 5/ 2 negated] raise: ExcepcionDominioFuncion.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionTangenteTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionTangenteTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:20'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaEvaluacionXALaNTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaEvaluacionXALaNTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:17'!testCrearEstrategiaDevuelveEstrategiaNoNula 	| estrategia |	estrategia := EstrategiaEvaluacionXALaN crearConExponente: 4.	self deny: (estrategia == nil).! !!EstrategiaEvaluacionXALaNTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 20:05'!testEvaluarEnValorDevuelveValorCorrecto	| estrategia estrategiaDos estrategiaSiete |	estrategiaDos := EstrategiaEvaluacionXALaN crearConExponente: 2.	estrategiaSiete := EstrategiaEvaluacionXALaN crearConExponente: 7.	self assert: ((estrategiaDos evaluarEn: 5) = 25).	self assert: ((estrategiaSiete evaluarEn: 2) = 128).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionXALaNTestCase class	instanceVariableNames: ''!!EstrategiaEvaluacionXALaNTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:20'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaIntegracionTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaIntegracionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 15:21'!testEstrategiaIntegracionIntegraLogaritmoNaturalXCorrectamente	| funcion estrategia |	funcion := MockFuncion new.	funcion formaEvaluacion: [:x| x log:Float e].	estrategia := EstrategiaIntegracion crearNueva.	self assert:((estrategia integrar: funcion  entre: 0.0000000001 y: 1) closeTo: -1).	self assert:((estrategia integrar: funcion  entre: 0.0000000001 y: Float e) closeTo: 0).! !!EstrategiaIntegracionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 15:16'!testEstrategiaIntegracionIntegraSenoXCorrectamente	| funcion estrategia |	funcion := MockFuncion new.	funcion formaEvaluacion: [:x| x sin].	estrategia := EstrategiaIntegracion crearNueva.	self assert:((estrategia integrar: funcion  entre: 0 y: 2 * Float pi) closeTo: 0).	self assert:((estrategia integrar: funcion  entre: 0 y:  Float pi) closeTo: 2).	self assert:((estrategia integrar: funcion  entre: 0 y: 3 * Float pi) closeTo: 2).	self assert:((estrategia integrar: funcion  entre:  Float pi y:  2 * Float pi) closeTo: -2).	self assert:((estrategia integrar: funcion  entre: -3 * Float pi y: 1 * Float pi) closeTo: 0).	self assert:((estrategia integrar: funcion  entre:  (Float pi / 2) y:  Float pi) closeTo: 1).! !!EstrategiaIntegracionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 14:36'!testEstrategiaIntegracionIntegraXCorrectamente	| funcion estrategia |	funcion := MockFuncion new.	funcion formaEvaluacion: [:x| x].	estrategia := EstrategiaIntegracion crearNueva.	self assert:((estrategia integrar:funcion entre: 0 y: 1) closeTo: 0.5).	self assert:((estrategia integrar:funcion entre: -1 y: 1) closeTo: 0).	self assert:((estrategia integrar:funcion entre: -2 y: -1) closeTo: -1.5).	self assert:((estrategia integrar:funcion entre: 1 y: 2) closeTo: 1.5).! !!EstrategiaIntegracionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 17:23'!testIntegralDesdeAHastaBEsIgualAMenosIntegralDesdeBHastaA	| funcion estrategia |	funcion := MockFuncion new.	funcion formaEvaluacion: [:x| x + x raisedTo: 2].	estrategia := EstrategiaIntegracion crearNueva.	self assert:((estrategia integrar:funcion entre: 0 y: 1) =  (estrategia integrar:funcion entre: 1 y: 0) negated).! !!EstrategiaIntegracionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 15:23'!testPuedeSetearSubIntervalosSoloUnaVez	| funcion estrategia |	funcion := MockFuncion new.	funcion formaEvaluacion: [:x| x].	estrategia := EstrategiaIntegracion crearNueva.	self should: [estrategia setSubIntervalos: 1] raise: Error.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaIntegracionTestCase class	instanceVariableNames: ''!!EstrategiaIntegracionTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 14:55'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaMaximosYMinimosContinuosTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaMaximosYMinimosContinuosTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 16:52'!testEvaluarMaximoDeXDevuelveValoresCorrectos	| estrategia funcion punto |	estrategia := EstrategiaMaximosYMinimosContinuos crearNueva.	funcion := MockFuncion new.	funcion formaEvaluacion: [:x| x].	punto := (estrategia obtenerMaximoDe: funcion desde: 0 hasta:1).	self assert: (punto getX closeTo: 1).	self assert: (punto getY closeTo: 1).	punto := (estrategia obtenerMaximoDe:funcion desde: 2.3 hasta:4).	self assert: (punto getX closeTo: 4).	self assert: (punto getY closeTo: 4).! !!EstrategiaMaximosYMinimosContinuosTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 16:59'!testEvaluarMaximoYMinimoDeCosenoDeXDevuelveValoresCorrectos	| estrategia funcion punto |	estrategia := EstrategiaMaximosYMinimosContinuos crearNueva.	funcion := MockFuncion new.	funcion formaEvaluacion: [:x| x cos].	punto := (estrategia obtenerMaximoDe: funcion desde: 0 hasta:Float pi * 2).	self assert: (punto getX closeTo: 0).	self assert: (punto getY closeTo: 1).	punto := (estrategia obtenerMinimoDe: funcion desde: 0 hasta:Float pi * 2).	self assert: (punto getX closeTo: Float pi).	self assert: (punto getY closeTo: -1).! !!EstrategiaMaximosYMinimosContinuosTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 18:36'!testEvaluarMaximoYMinimoEnIntervaloIncorrectoLanzaExcepcion	| estrategia funcion punto |	estrategia := EstrategiaMaximosYMinimosContinuos crearNueva.	funcion := MockFuncion new.	funcion formaEvaluacion: [:x| x cos].	self should:[estrategia obtenerMaximoDe: funcion desde: 40 hasta:Float pi * 2] raise: ExcepcionEvaluacionIntervalo.	self should:[estrategia obtenerMinimoDe: funcion desde: 40 hasta:Float pi * 2] raise: ExcepcionEvaluacionIntervalo.! !!EstrategiaMaximosYMinimosContinuosTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 16:55'!testEvaluarMinimoDeXDevuelveValoresCorrectos	| estrategia funcion punto |	estrategia := EstrategiaMaximosYMinimosContinuos crearNueva.	funcion := MockFuncion new.	funcion formaEvaluacion: [:x| -1 * x].	punto := (estrategia obtenerMinimoDe: funcion desde: 0 hasta:1).	self assert: (punto getX closeTo: 1).	self assert: (punto getY closeTo: -1).	punto := (estrategia obtenerMinimoDe:funcion desde: 2.3 hasta:4).	self assert: (punto getX closeTo: 4).	self assert: (punto getY closeTo: -4).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaMaximosYMinimosContinuosTestCase class	instanceVariableNames: ''!!EstrategiaMaximosYMinimosContinuosTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 17:01'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #EstrategiaMaximosYMinimosDiscretosTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!EstrategiaMaximosYMinimosDiscretosTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 18:07'!testEvaluarMaximoDeXFactorialDevuelveValoresCorrectos	| estrategia funcion punto |	estrategia := EstrategiaMaximosYMinimosDiscretos crearNueva.	funcion := MockFuncion new.	funcion formaEvaluacion: [:x| x factorial].	punto := (estrategia obtenerMaximoDe: funcion desde: 1 hasta:5).	self assert: (punto getX closeTo: 5).	self assert: (punto getY closeTo: 120).	punto := (estrategia obtenerMaximoDe:funcion desde: 4 hasta:8).	self assert: (punto getX closeTo: 8).	self assert: (punto getY closeTo: 40320).! !!EstrategiaMaximosYMinimosDiscretosTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 18:09'!testEvaluarMinimoDeXFactorialDevuelveValoresCorrectos	| estrategia funcion punto |	estrategia := EstrategiaMaximosYMinimosDiscretos crearNueva.	funcion := MockFuncion new.	funcion formaEvaluacion: [:x| x factorial].	punto := (estrategia obtenerMinimoDe: funcion desde: 1 hasta:5).	self assert: (punto getX closeTo: 1).	self assert: (punto getY closeTo: 1).	punto := (estrategia obtenerMinimoDe:funcion desde: 4 hasta:8).	self assert: (punto getX closeTo: 4).	self assert: (punto getY closeTo: 24).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaMaximosYMinimosDiscretosTestCase class	instanceVariableNames: ''!!EstrategiaMaximosYMinimosDiscretosTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 17:01'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #ExtensionesNumerosTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!ExtensionesNumerosTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 16:04'!testEsNaturalOCeroDevuelveTrueConValoresCorrectos	self assert: (ExtensionesNumeros esNaturalOCero: 5).	self assert: (ExtensionesNumeros esNaturalOCero: 0).	self deny: (ExtensionesNumeros esNaturalOCero: -5).	self deny: (ExtensionesNumeros esNaturalOCero: 0.4).	self deny: (ExtensionesNumeros esNaturalOCero: -0.4).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ExtensionesNumerosTestCase class	instanceVariableNames: ''!!ExtensionesNumerosTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:20'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #FabricaDeFuncionesTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 19:28'!testCrearEstrategiaConstantePasandoValorNoNumericoTiraExcepcion	| fabrica  funcion |	fabrica := FabricaFunciones new.	funcion := MockFuncion new.	self should: [fabrica crearConstante: funcion]  raise: ExcepcionArgumentoInvalido.	! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 20:13'!testCrearEstrategiaXALaNPasandoExponenteNoNumericoTiraExcepcion	| fabrica  funcion |	fabrica := FabricaFunciones new.	funcion := MockFuncion new.	self should: [fabrica crearXALaNConExponente: funcion]  raise: ExcepcionArgumentoInvalido.	! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:26'!testCrearFuncionArcoCosenoDevuelveFuncionNoNula	| fabrica funcionUno funcion |	fabrica := FabricaFunciones new.	funcionUno := MockFuncion new.	funcion :=	fabrica crearArcoCoseno: funcionUno.	self	deny: (funcion == nil).! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:33'!testCrearFuncionArcoSenoDevuelveFuncionNoNula	| fabrica funcionUno funcion |	fabrica := FabricaFunciones new.	funcionUno := MockFuncion new.	funcion :=	fabrica crearArcoSeno: funcionUno.	self	deny: (funcion == nil).! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:38'!testCrearFuncionConstanteDevuelveFuncionNoNula	| fabrica funcion |	fabrica := FabricaFunciones new.	funcion :=	fabrica crearConstante: 4.	self	deny: (funcion == nil).! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:27'!testCrearFuncionCosenoDevuelveFuncionNoNula	| fabrica funcionUno funcion |	fabrica := FabricaFunciones new.	funcionUno := MockFuncion new.	funcion :=	fabrica crearCoseno: funcionUno.	self	deny: (funcion == nil).! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:33'!testCrearFuncionDivisionDevuelveFuncionNoNula	| fabrica funcionUno funcionDos funcion |	fabrica := FabricaFunciones new.	funcionUno := MockFuncion new.	funcionDos := MockFuncion new.	funcion :=	fabrica crearDivision: funcionUno y: funcionDos.	self	deny: (funcion == nil).! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:04'!testCrearFuncionExponencialDevuelveFuncionNoNula	| fabrica funcionUno funcionDos funcion |	fabrica := FabricaFunciones new.	funcionUno := MockFuncion new.	funcionDos := MockFuncion new.	funcion :=	fabrica crearExponencial: funcionUno y: funcionDos.	self	deny: (funcion == nil).! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:30'!testCrearFuncionFactorialDevuelveFuncionNoNula	| fabrica funcionUno funcion |	fabrica := FabricaFunciones new.	funcionUno := MockFuncion new.	funcion :=	fabrica crearFactorial: funcionUno.	self	deny: (funcion == nil).! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:28'!testCrearFuncionFibonacciDevuelveFuncionNoNula	| fabrica funcionUno funcion |	fabrica := FabricaFunciones new.	funcionUno := MockFuncion new.	funcion :=	fabrica crearFibonacci: funcionUno.	self	deny: (funcion == nil).! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:34'!testCrearFuncionLogaritmoNaturalDevuelveFuncionNoNula	| fabrica funcionUno funcion |	fabrica := FabricaFunciones new.	funcionUno := MockFuncion new.	funcion :=	fabrica crearLogaritmoNatural: funcionUno.	self	deny: (funcion == nil).! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:01'!testCrearFuncionMultiplicacionDevuelveFuncionNoNula	| fabrica funcionUno funcionDos funcion |	fabrica := FabricaFunciones new.	funcionUno := MockFuncion new.	funcionDos := MockFuncion new.	funcion :=	fabrica crearMultiplicacion: funcionUno y: funcionDos.	self	deny: (funcion == nil).! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:03'!testCrearFuncionRestaDevuelveFuncionNoNula	| fabrica funcionUno funcionDos funcion |	fabrica := FabricaFunciones new.	funcionUno := MockFuncion new.	funcionDos := MockFuncion new.	funcion :=	fabrica crearResta: funcionUno y: funcionDos.	self	deny: (funcion == nil).! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:31'!testCrearFuncionSenoDevuelveFuncionNoNula	| fabrica funcionUno funcion |	fabrica := FabricaFunciones new.	funcionUno := MockFuncion new.	funcion :=	fabrica crearSeno: funcionUno.	self	deny: (funcion == nil).! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:02'!testCrearFuncionSumaDevuelveFuncionNoNula	| fabrica funcionUno funcionDos funcion |	fabrica := FabricaFunciones new.	funcionUno := MockFuncion new.	funcionDos := MockFuncion new.	funcion :=	fabrica crearSuma: funcionUno y: funcionDos.	self	deny: (funcion == nil).! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:32'!testCrearFuncionTangenteDevuelveFuncionNoNula	| fabrica funcionUno funcion |	fabrica := FabricaFunciones new.	funcionUno := MockFuncion new.	funcion :=	fabrica crearTangente: funcionUno.	self	deny: (funcion == nil).! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:35'!testCrearFuncionXALaNDevuelveFuncionNoNula	| fabrica funcion |	fabrica := FabricaFunciones new.	funcion :=	fabrica crearXALaNConExponente: 6.	self	deny: (funcion == nil).! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:35'!testCrearTerminoPolinomialDevuelveFuncionNoNula	| fabrica funcion|	fabrica := FabricaFunciones new.	funcion := fabrica crearTerminoPolinomialConMultiplicador: 6 exponente: 4.	self deny: (funcion == nil).! !!FabricaDeFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:36'!testCrearXDevuelveFuncionNoNula	| fabrica funcion|	fabrica := FabricaFunciones new.	funcion := fabrica crearX.	self deny: (funcion == nil).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FabricaDeFuncionesTestCase class	instanceVariableNames: ''!!FabricaDeFuncionesTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:20'!packageNamesUnderTest	^ #('TP190728')! !TestCase subclass: #FuncionTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!FuncionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/12/2010 22:16'!testComponerConEnValorLlamaEvaluarDeFuncionAComponerYEvaluarEnDeEstrategiaEnValorRecibido	| estrategia f g |	estrategia := MockEstrategiaEvaluacion new.	f := Funcion crearConEstrategiaEvaluacion: estrategia.	g :=	MockFuncion new.	g formaEvaluacion: [:x | x + 2].	f componerCon: g evaluarEn: 4.	self	assert: (estrategia getEvaluarEnFueLlamadoCon = 6)! !!FuncionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 15:40'!testCrearFuncionConEstrategiaDevuelveFuncionNoNula	| funcion estrategia |	estrategia := MockEstrategiaEvaluacion crearNueva.	funcion :=  Funcion crearConEstrategiaEvaluacion: estrategia estrategiaEvaluacionIntervalos: nil estrategiaDerivacion: nil estrategiaIntegracion: nil.	self deny: (funcion == nil).! !!FuncionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/15/2010 20:39'!testCrearFuncionConEstrategiaEvaluacionEIntervalosDevuelveFuncionNoNula	| funcion estrategiaEvaluacion estrategiaIntervalos |	estrategiaEvaluacion := MockEstrategiaEvaluacion crearNueva.	estrategiaIntervalos := MockEstrategiaEvaluacionIntervalo crearNueva.	funcion := Funcion crearConEstrategiaEvaluacion: estrategiaEvaluacion  estrategiaEvaluacionIntervalos: estrategiaIntervalos.	self deny: (funcion == nil).! !!FuncionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 15:33'!testDerivarEnLlamaDerivarEnDeEstrategiaEvaluacion	| estrategia funcion |	estrategia := MockEstrategiaDerivacion crearNueva.	funcion := Funcion crearConEstrategiaEvaluacion: nil estrategiaEvaluacionIntervalos: nil estrategiaDerivacion: estrategia estrategiaIntegracion: nil.	funcion derivarEn: 5.	self	assert: (estrategia getDerivarEnFueLlamado)! !!FuncionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 12:38'!testDerivarFuncionSinEstrategiaDerivacionLanzaExcepcion	| funcion |	funcion := Funcion new.	self should: [funcion derivarEn: 4] raise: ExcepcionOperacionAritmeticaInvalida.	! !!FuncionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/12/2010 23:53'!testEvaluarEnIntervaloLlamaEstrategiaEvaluacionIntervalosSiPuede	| estrategiaIntervalo estrategiaEvaluacion funcion |	estrategiaIntervalo := MockEstrategiaEvaluacionIntervalo crearNueva.	estrategiaEvaluacion := MockEstrategiaEvaluacion new.	funcion := Funcion crearConEstrategiaEvaluacion: estrategiaEvaluacion estrategiaEvaluacionIntervalos: estrategiaIntervalo.	funcion evaluarDesde: 5  hasta: 6  cada: 0.5.	self	assert: (estrategiaIntervalo getPuedeEvaluarEntreFueLlamado).	self	assert: (estrategiaIntervalo getEvaluarEntreFueLlamado)! !!FuncionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/12/2010 23:52'!testEvaluarEnInvervaloLanzaExcepcionSiNoPuede	| estrategiaIntervalo estrategiaEvaluacion funcion |	estrategiaIntervalo := MockEstrategiaEvaluacionIntervalo crearNueva.	estrategiaEvaluacion := MockEstrategiaEvaluacion new.	estrategiaIntervalo setPuedeEvaluar: false.	funcion := Funcion crearConEstrategiaEvaluacion: estrategiaEvaluacion estrategiaEvaluacionIntervalos: estrategiaIntervalo.	self should:	[funcion evaluarDesde: 7  hasta: 6  cada: 0.5] raise:ExcepcionEvaluacionIntervalo.! !!FuncionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/12/2010 22:46'!testEvaluarEnLlamaEvaluarEnDeEstrategiaEvaluacion	| estrategia funcion |	estrategia := MockEstrategiaEvaluacion new.	funcion := Funcion crearConEstrategiaEvaluacion: estrategia.	funcion evaluarEn: 5.	self	assert: (estrategia getEvaluarEntreFueLlamado)! !!FuncionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 15:51'!testIntegrarLlamaEstrategiaIntegracion	| estrategia funcion |	estrategia := MockEstrategiaIntegracion crearNueva.	funcion := Funcion crearConEstrategiaEvaluacion: nil estrategiaEvaluacionIntervalos: nil estrategiaDerivacion: nil estrategiaIntegracion: estrategia.	funcion integrarEntre: 2 y: 5.	self	assert: (estrategia getIntegrarFueLlamado)! !!FuncionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 18:18'!testObtenerMaximoEntreAyBLlamaEstrategiaExtremos	| estrategia funcion |	estrategia := MockEstrategiaMaximosYMinimos crearNueva.	funcion := Funcion crearConEstrategiaEvaluacion: nil estrategiaEvaluacionIntervalos: nil estrategiaDerivacion: nil estrategiaIntegracion: nil estrategiaExtremos: estrategia.	funcion obtenerMaximoEntre: 5 y: 6.	self	assert: (estrategia getObtenerMaximoFueLlamado)! !!FuncionTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 18:14'!testSetearEstrategiasYaSeteadasLanzaError	| estrategiaIntervalo estrategiaEvaluacion estrategiaDerivacion funcion estrategiaIntegracion estrategiaExtremos |	estrategiaIntervalo := MockEstrategiaEvaluacionIntervalo crearNueva.	estrategiaEvaluacion := MockEstrategiaEvaluacion new.	estrategiaDerivacion := MockEstrategiaDerivacion new.	estrategiaIntegracion := MockEstrategiaIntegracion new.	estrategiaExtremos := MockEstrategiaMaximosYMinimos new.	funcion := Funcion crearConEstrategiaEvaluacion: estrategiaEvaluacion estrategiaEvaluacionIntervalos: estrategiaIntervalo estrategiaDerivacion: estrategiaDerivacion estrategiaIntegracion: estrategiaIntegracion estrategiaExtremos: estrategiaExtremos.	self should: [funcion setEstrategiaEvaluacionIntervalos: estrategiaIntervalo] raise: Error.	self should: [funcion setEstrategiaEvaluacion: estrategiaEvaluacion] raise: Error.	self should: [funcion setEstrategiaDerivacion: estrategiaDerivacion] raise: Error.	self should: [funcion setEstrategiaIntegracion: estrategiaIntegracion] raise: Error.	self should: [funcion setEstrategiaExtremos: estrategiaExtremos] raise: Error.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FuncionTestCase class	instanceVariableNames: ''!!FuncionTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:20'!packageNamesUnderTest	^ #('TP190728')! !Object subclass: #MockEstrategiaDerivacion	instanceVariableNames: 'derivarEnFueLlamado'	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!MockEstrategiaDerivacion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 12:54'!getDerivarEnFueLlamado	^derivarEnFueLlamado! !!MockEstrategiaDerivacion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 12:50'!setDerivarEnFueLlamado: valor	derivarEnFueLlamado := valor.! !!MockEstrategiaDerivacion methodsFor: 'Derivacion' stamp: 'DamianSchenkelman 4/17/2010 12:55'!derivarEn: numero	self setDerivarEnFueLlamado: true.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MockEstrategiaDerivacion class	instanceVariableNames: ''!!MockEstrategiaDerivacion class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/17/2010 12:49'!crearNueva	| estrategia |		estrategia := MockEstrategiaDerivacion new.	estrategia setDerivarEnFueLlamado: false.	^estrategia.! !EstrategiaEvaluacion subclass: #MockEstrategiaEvaluacion	instanceVariableNames: 'evaluarLlamado evaluarLlamadoCon'	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!MockEstrategiaEvaluacion methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/11/2010 21:28'!evaluarEn: numero	evaluarLlamado := true.	evaluarLlamadoCon := numero! !!MockEstrategiaEvaluacion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/11/2010 21:28'!getEvaluarEnFueLlamadoCon 	^evaluarLlamadoCon ! !!MockEstrategiaEvaluacion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/12/2010 22:46'!getEvaluarEntreFueLlamado	^evaluarLlamado ! !!MockEstrategiaEvaluacion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/12/2010 22:46'!setEvaluarEntreFueLlamado: valor	evaluarLlamado := valor.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MockEstrategiaEvaluacion class	instanceVariableNames: ''!!MockEstrategiaEvaluacion class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/12/2010 22:46'!crearNueva	| estrategia |	estrategia := MockEstrategiaEvaluacion new.	estrategia setEvaluarEntreFueLlamado: false.	^estrategia.! !EstrategiaEvaluacionIntervalo subclass: #MockEstrategiaEvaluacionIntervalo	instanceVariableNames: 'evaluarLlamado puedeEvaluarFueLlamado puedeEvaluar'	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!MockEstrategiaEvaluacionIntervalo methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/12/2010 23:21'!evaluar: funcion desde: inicial  hasta: final  cada: intervalo	self	setEvaluarEntreFueLlamado:true.! !!MockEstrategiaEvaluacionIntervalo methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/12/2010 23:43'!puedeEvaluarDesde: inicial hasta: final  cada: intervalo	self setPuedeEvaluarEntreFueLlamado: true.	^puedeEvaluar! !!MockEstrategiaEvaluacionIntervalo methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/12/2010 22:46'!getEvaluarEntreFueLlamado	^evaluarLlamado ! !!MockEstrategiaEvaluacionIntervalo methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/12/2010 22:49'!getPuedeEvaluarEntreFueLlamado	^puedeEvaluarFueLlamado! !!MockEstrategiaEvaluacionIntervalo methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/12/2010 22:46'!setEvaluarEntreFueLlamado: valor	evaluarLlamado := valor.! !!MockEstrategiaEvaluacionIntervalo methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/12/2010 23:43'!setPuedeEvaluar: valor	puedeEvaluar := valor! !!MockEstrategiaEvaluacionIntervalo methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/12/2010 22:49'!setPuedeEvaluarEntreFueLlamado: valor	puedeEvaluarFueLlamado := valor! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MockEstrategiaEvaluacionIntervalo class	instanceVariableNames: ''!!MockEstrategiaEvaluacionIntervalo class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/12/2010 23:45'!crearNueva	| estrategia |	estrategia := MockEstrategiaEvaluacionIntervalo  new.	estrategia setEvaluarEntreFueLlamado: false.	estrategia setPuedeEvaluarEntreFueLlamado: false.	estrategia setPuedeEvaluar: true.	^estrategia.! !Object subclass: #MockEstrategiaIntegracion	instanceVariableNames: 'integrarFueLlamado'	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!MockEstrategiaIntegracion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 15:52'!getIntegrarFueLlamado 	^integrarFueLlamado! !!MockEstrategiaIntegracion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 15:47'!setIntegrarFueLlamando: valor	integrarFueLlamado := valor.! !!MockEstrategiaIntegracion methodsFor: 'Integracion' stamp: 'DamianSchenkelman 4/17/2010 15:51'!integrar:funcion entre: a y: b	self setIntegrarFueLlamando: true.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MockEstrategiaIntegracion class	instanceVariableNames: ''!!MockEstrategiaIntegracion class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/17/2010 18:20'!crearNueva	| estrategia |	estrategia := MockEstrategiaIntegracion new.	estrategia setIntegrarFueLlamando: false.	^estrategia.! !Object subclass: #MockEstrategiaMaximosYMinimos	instanceVariableNames: 'obtenerMaximoFueLlamado'	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!MockEstrategiaMaximosYMinimos methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 18:25'!getObtenerMaximoFueLlamado	^obtenerMaximoFueLlamado ! !!MockEstrategiaMaximosYMinimos methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 18:21'!setObtenerMaximoFueLlamado: valor	obtenerMaximoFueLlamado := valor! !!MockEstrategiaMaximosYMinimos methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/17/2010 18:25'!obtenerMaximoDe: funcion desde: inicial  hasta: final	self setObtenerMaximoFueLlamado: true.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MockEstrategiaMaximosYMinimos class	instanceVariableNames: ''!!MockEstrategiaMaximosYMinimos class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/17/2010 18:20'!crearNueva	| estrategia |	estrategia := MockEstrategiaMaximosYMinimos new.	estrategia setObtenerMaximoFueLlamado: false.	^estrategia.! !Object subclass: #MockFuncion	instanceVariableNames: 'bloqueEvaluacion'	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!MockFuncion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/10/2010 15:24'!formaEvaluacion: unBloque	"Recibe un block para mockear la estrategia de evaluacion. Lo guarda en un campo de instancia."	bloqueEvaluacion := unBloque. ! !!MockFuncion methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/10/2010 15:34'!evaluarEn: numero	"Evalua el bloque de evaluacion en el numero recibido como parametro y devuelve el valor obtenido."	^(bloqueEvaluacion value: numero).! !TestCase subclass: #PruebaIntegracionFuncionesTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728-Tests'!!PruebaIntegracionFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 21:42'!testPruebaDos	| fabrica f g |	fabrica := FabricaFunciones new.	f := fabrica crearFibonacci: (fabrica crearX).	g := fabrica crearFactorial: (fabrica crearX).	self assert: 	((f evaluarEn: 3) = 2).	self assert: 	((f evaluarEn: 8) = 21).	self assert: ((g evaluarEn: 3) = 6).	self assert: ((g evaluarEn: 10) = 3628800).	self should: [g evaluarEn: -2] raise: ExcepcionDominioFuncion.	self assert: ((g componerCon: f evaluarEn:  4) = 6).! !!PruebaIntegracionFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/13/2010 01:06'!testPruebaTres	| fabrica f resultados |	fabrica := FabricaFunciones new.	f := fabrica crearFactorial: (fabrica crearX).	resultados := f evaluarDesde: 1 hasta: 5 cada: 2.	self assert: ((resultados at: 1) = 1).	self should: [resultados at: 2] raise: Error.	self assert: ((resultados at: 3) = 6).	self assert: ((resultados at: 5) = 120).! !!PruebaIntegracionFuncionesTestCase methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/11/2010 21:35'!testPruebaUno	| fabrica primerTerminoF segundoTerminoF  primerTerminoG segundoTerminoG f g|	fabrica := FabricaFunciones new.	primerTerminoF := fabrica crearTerminoPolinomialConMultiplicador: 5 exponente: 1.	segundoTerminoF := fabrica crearTerminoPolinomialConMultiplicador: (1/3) exponente: 1.	primerTerminoG := fabrica crearExponencial: (fabrica crearConstante: 5) y: (fabrica crearX).	segundoTerminoG := fabrica crearConstante: 7.	f := fabrica crearSuma: primerTerminoF y: segundoTerminoF.	g := fabrica crearResta: primerTerminoG  y: segundoTerminoG.	self	assert: ((f evaluarEn: 9) = 48).	self	assert: ((f evaluarEn: 0) = 0).	self	assert: ((g evaluarEn: 2) = 18).	self	assert: ((g evaluarEn: 0) = -6).	"El enunciado del TP tiene mal el resultado del assert de abajo."	self assert: ((f componerCon: g evaluarEn: 1) = (-32/3)).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PruebaIntegracionFuncionesTestCase class	instanceVariableNames: ''!!PruebaIntegracionFuncionesTestCase class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/14/2010 23:20'!packageNamesUnderTest	^ #('TP190728')! !