Object subclass: #EstrategiaDerivacion	instanceVariableNames: 'diferencialX'	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaDerivacion methodsFor: 'Derivacion' stamp: 'DamianSchenkelman 4/17/2010 12:31'!derivar: funcion en: numero	"Recibe una funcion y un numero. Calcula la derivada numerica de la funcion en ese valor. Si la derivacion lanza una excepcion deja que se propague."	| derivada funcionEnNumero funcionEnNumeroMasDiferencial |	funcionEnNumeroMasDiferencial := funcion evaluarEn: (numero + diferencialX).	funcionEnNumero := funcion evaluarEn: (numero).	derivada := (funcionEnNumeroMasDiferencial - funcionEnNumero / diferencialX).	^derivada! !!EstrategiaDerivacion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 12:10'!setDiferencialX: numero	"Deberia ser usado solo una vez en el momento de creacion."	(diferencialX ~= nil)ifTrue:	[		Error new signal: 'No se puede volver a setear'.	].	diferencialX := numero.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaDerivacion class	instanceVariableNames: ''!!EstrategiaDerivacion class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/17/2010 12:34'!crearNueva	"Crea una nueva estrategia de derivacion y la devuelve."	| estrategia |	estrategia := EstrategiaDerivacion new.	estrategia setDiferencialX: 0.000000000001.	^estrategia.! !Object subclass: #EstrategiaEvaluacion	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacion methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/10/2010 17:17'!evaluarEn: numero	"Metodo abstracto que debe ser implementado por todas las estrategias de evaluacion."	self subclassResponsibility.! !EstrategiaEvaluacion subclass: #EstrategiaEvaluacionConstantes	instanceVariableNames: 'constante'	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionConstantes methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/10/2010 16:03'!setConstante: numero	"Setea el atributo constante con el parametro recibido."	constante := numero.! !!EstrategiaEvaluacionConstantes methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/10/2010 12:57'!evaluarEn: unNumero	"Recibe un numero. Evalua la funcion constante en ese numero (devuelve el valor de la constante)."	^ constante.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionConstantes class	instanceVariableNames: ''!!EstrategiaEvaluacionConstantes class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/10/2010 16:04'!crearNueva: numero	"Crea una nueva estrategia. Le setea el valor al atributo constante y la devuelve."	| estrategia |	estrategia := EstrategiaEvaluacionConstantes new.	estrategia setConstante: numero.	^estrategia.! !EstrategiaEvaluacion subclass: #EstrategiaEvaluacionDeDosFunciones	instanceVariableNames: 'funcionUno funcionDos'	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionDeDosFunciones methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/10/2010 17:38'!setFuncionUno: funUno setFuncionDos: funDos	"Recibe dos funciones y las guarda en atributos de la instancia."	funcionUno  := funUno.	funcionDos  := funDos.! !EstrategiaEvaluacion subclass: #EstrategiaEvaluacionDeUnaFuncion	instanceVariableNames: 'funcion'	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionDeUnaFuncion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/10/2010 19:45'!setFuncion: func	"Setea la funcion, guardandola en un atributo."	funcion := func! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionDeUnaFuncion class	instanceVariableNames: ''!!EstrategiaEvaluacionDeUnaFuncion class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/11/2010 16:41'!crearNueva: clase conFuncion: funcion	"comment stating purpose of message"	| estrategia |	estrategia := clase new.	estrategia setFuncion: funcion.	^estrategia.! !EstrategiaEvaluacionDeUnaFuncion subclass: #EstrategiaEvaluacionArcoCoseno	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionArcoCoseno methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/15/2010 20:22'!evaluarEn: numero	"Recibe un numero. Evalua la funcion en ese numero para obtener el argumento. Si el modulo del argumento es mayor o igual a uno lanza una excepcion ExcepcionDominioFuncion."	| argumento |	argumento := funcion evaluarEn: numero.	(argumento abs >= 1)ifTrue:	[		ExcepcionDominioFuncion new signal.	].	^argumento arcCos.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionArcoCoseno class	instanceVariableNames: ''!!EstrategiaEvaluacionArcoCoseno class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/11/2010 17:14'!crearNueva: funcion	"Recibe una funcion. Crea una nueva instancia de la estrategia y setea la funcion. Devuelve la estrategia."	^(super crearNueva: self conFuncion: funcion).	! !EstrategiaEvaluacionDeUnaFuncion subclass: #EstrategiaEvaluacionArcoSeno	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionArcoSeno methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/15/2010 20:22'!evaluarEn: numero	"Recibe un numero. Evalua la funcion en ese numero para obtener el argumento. Calcula el arco seno del argumento. Si el modulo del argumento es mayor a uno lanza una excepcion del tipo ExcepcionDominioFuncion."	| argumento |	argumento := funcion evaluarEn: numero.	(argumento abs <= 1)ifFalse: 	[		ExcepcionDominioFuncion new signal.	].	^argumento arcSin.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionArcoSeno class	instanceVariableNames: ''!!EstrategiaEvaluacionArcoSeno class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/11/2010 17:14'!crearNueva: funcion	"Recibe una funcion. Crea una nueva instancia de la estrategia y le setea la funcion. Devuelve la estrategia."	^(super crearNueva: self conFuncion: funcion).! !EstrategiaEvaluacionDeUnaFuncion subclass: #EstrategiaEvaluacionCoseno	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionCoseno methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/15/2010 20:24'!evaluarEn: numero	"Recibe un numero. Evalua la funcion en ese numero y luego calcula el coseno. Devuelve el resultado."	^((funcion evaluarEn: numero) cos)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionCoseno class	instanceVariableNames: ''!!EstrategiaEvaluacionCoseno class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/11/2010 17:15'!crearNueva: funcion	"Recibe una funcion como parametro. Crea una nueva instancia de la estrategia y le setea la funcion. Devuelve la estrategia."	^(super crearNueva: self conFuncion: funcion).! !EstrategiaEvaluacionDeDosFunciones subclass: #EstrategiaEvaluacionDivision	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionDivision methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/10/2010 17:40'!setNumerador: numerador setDenominador: denominador	"Recibe el numerador y denominador y lo setea a los atributos correspondientes."	super setFuncionUno: numerador  setFuncionDos: denominador.! !!EstrategiaEvaluacionDivision methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/15/2010 19:53'!evaluarEn: numero	"Recibe un numero. Evalua las funciones numerador y denominador en ese numero y las divide. Devuelve el resultado."	"La linea de abajo podria tirar una excepcion ZeroDivide. Esto es algo tenido en cuenta y he decidido que en caso que el escenario se presente esa es la excepcion que debe ser lanzada."	^((funcionUno  evaluarEn: numero )/(funcionDos  evaluarEn: numero))	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionDivision class	instanceVariableNames: ''!!EstrategiaEvaluacionDivision class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/10/2010 17:01'!crearNuevaCon: numerador y: denominador	"Crea una nueva instancia de la estrategia. Recibe las funciones numerador y denominador y las asigna a los atributos respectivos. Devuelve la estrategia."	| estrategia |	estrategia := EstrategiaEvaluacionDivision new.	estrategia setNumerador: numerador setDenominador: denominador.	^estrategia.! !EstrategiaEvaluacionDeDosFunciones subclass: #EstrategiaEvaluacionExponencial	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionExponencial methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/10/2010 19:12'!setBase: base setExponente: exponente	"Recibe una base y un exponente y los guarda como atributos."	super setFuncionUno: base setFuncionDos: exponente.! !!EstrategiaEvaluacionExponencial methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/15/2010 19:54'!evaluarEn: numero	"Recibe un numero. Evalua las funciones base y exponente. Eleva la base al exponente y devuelve el valor obtenido."	^((funcionUno evaluarEn: numero) raisedTo: (funcionDos evaluarEn: numero))! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionExponencial class	instanceVariableNames: ''!!EstrategiaEvaluacionExponencial class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/10/2010 19:11'!crearNuevaCon: base y: exponente	"Crea una nueva instancia de la estrategia. Recibe las funciones base y exponente y las guarda en atributos de la nuvea instancia. Devuelve la estrategia."	| estrategia |	estrategia := EstrategiaEvaluacionExponencial new.	estrategia setBase: base setExponente: exponente.	^estrategia.! !EstrategiaEvaluacionDeUnaFuncion subclass: #EstrategiaEvaluacionFactorial	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionFactorial methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/15/2010 20:22'!evaluarEn: numero	"Recibe un numero. Evalua la funcion en ese numero y calcula el factorial del resultado. Devuelve el resultado de factorial. Si el argumento del factorial no esta en el dominio lanza una excepcion ExcepcionFactorial."	| argumento |	argumento := ((funcion) evaluarEn: numero).	(ExtensionesNumeros esNaturalOCero: argumento) ifFalse:	[		ExcepcionDominioFuncion new signal.	].	^(argumento factorial).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionFactorial class	instanceVariableNames: ''!!EstrategiaEvaluacionFactorial class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/11/2010 17:15'!crearNueva: funcion	"Recibe una funcion como parametro. Crea una nueva instancia de la estrategia y le setea la funcion. Devuelve la estrategia."	^(super crearNueva: self conFuncion: funcion).! !EstrategiaEvaluacionDeUnaFuncion subclass: #EstrategiaEvaluacionFibonacci	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionFibonacci methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/15/2010 20:22'!evaluarEn: numero	"Recibe un numero. Evalua la funcion en el numero para obtener el numero de la serie a obtener. Si no es natural o cero lanza una excepcion ExcepcionDominioFuncion."	| argumento num1 num2 res |	argumento := funcion evaluarEn: numero.	(ExtensionesNumeros esNaturalOCero: argumento)ifFalse: 	[		ExcepcionDominioFuncion new signal.	].	(argumento = 0)ifTrue:	[		^0	].	(argumento = 1)ifTrue:	[		^1	].	num1 := 0.	num2 := 1.	argumento timesRepeat:	[		res := num1 + num2.		num2 := num1.		num1 := res	].	^res! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionFibonacci class	instanceVariableNames: ''!!EstrategiaEvaluacionFibonacci class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/11/2010 17:15'!crearNueva: funcion	"Recibe una funcion. Crea una nueva instancia de la estrategia y le setea la funcion. Devuelve la estrategia."	^(super crearNueva: self conFuncion: funcion).! !Object subclass: #EstrategiaEvaluacionIntervalo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionIntervalo methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/18/2010 11:07'!evaluar: funcion desde: inicial  hasta: final  cada: intervalo	"Recibe una funcion, un valor inicial, un final y el intervalo. Evalua la funcion entre los valores iniciales y finales en intervalos definidos por intervalo. Devuelve un diccionario con las claves del valor de x y valores el valor de y. No devuelve una coleccion de puntos, porque considero que es mas usable un diccionario en este caso."	| resultados resultado |	resultados := Dictionary new.	inicial to: final by: intervalo do:	[:x|		resultado := funcion evaluarEn: x.		resultados at: x put: resultado.	].	^resultados. ! !!EstrategiaEvaluacionIntervalo methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/12/2010 22:56'!puedeEvaluarDesde: inicial hasta: final cada: intervalo	self subclassResponsibility! !EstrategiaEvaluacionIntervalo subclass: #EstrategiaEvaluacionIntervaloContinuo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionIntervaloContinuo methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/13/2010 00:59'!evaluar: funcion desde: inicial  hasta: final  cada: intervalo	"Recibe una funcion, un valor inicial, un final y el intervalo. Evalua la funcion entre los valores iniciales y finales en intervalos definidos por intervalo. Devuelve un diccionario con las claves del valor de x y valores el valor de y. Si la evaluacion en el intervalo lanza una excepcion del tipo ExcepcionDominioFuncion, lanza una nueva excepcion del tipo ExcepcionEvaluacionIntervalo."	[^super evaluar: funcion desde: inicial  hasta: final cada: intervalo] on: ExcepcionDominioFuncion  do:[ExcepcionEvaluacionIntervalo new signal].! !!EstrategiaEvaluacionIntervaloContinuo methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/18/2010 10:47'!puedeEvaluarDesde: inicial hasta: final cada: intervalo	"Recibe un valor inicial, uno final y un intervalo. Devuelve false si el intervalo es menor a cero, si el valor inicial es mayor o igual al final o s¡ la diferencia entre el valor final e inicial es menor al intervalo. Devuelve false en caso contrario."	^ExtensionesNumeros esCrecienteYNoVacioDesde: inicial  hasta: final cada: intervalo.! !EstrategiaEvaluacionIntervalo subclass: #EstrategiaEvaluacionIntervaloDiscreto	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionIntervaloDiscreto methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/12/2010 23:40'!evaluar: funcion desde: inicial  hasta: final  cada: intervalo	"Recibe una funcion, un valor inicial, un final y el intervalo. Evalua la funcion entre los valores iniciales y finales en intervalos definidos por intervalo. Devuelve un diccionario con las claves del valor de x y valores el valor de y."	^super evaluar: funcion desde: inicial  hasta: final cada: intervalo.! !!EstrategiaEvaluacionIntervaloDiscreto methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/18/2010 10:47'!puedeEvaluarDesde: inicial hasta: final cada: intervalo	"Recibe un valor inicial, uno final y un intervalo. Devuelve false si el intervalo es menor a cero, si el valor inicial es mayor o igual al final o s¡ la diferencia entre el valor final e inicial es menor al intervalo. Devuelve false en caso contrario."	| puedeEvaluar |	puedeEvaluar := ExtensionesNumeros esCrecienteYNoVacioDesde: inicial  hasta: final cada: intervalo.	(puedeEvaluar)ifTrue: 	[		^((ExtensionesNumeros esNaturalOCero: inicial) & (ExtensionesNumeros esNatural: final) & (ExtensionesNumeros esNatural: intervalo))	]	ifFalse:	[		^false.	].! !EstrategiaEvaluacionDeUnaFuncion subclass: #EstrategiaEvaluacionLogaritmoNatural	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionLogaritmoNatural methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/15/2010 20:23'!evaluarEn: numero	"Recibe un numero. Evalua la funcion en ese numero para obtener el argumento  y luego calcula el logaritmo natural. Devuelve el resultado. Si el argumento es menor o igual a cero lanza una excepcion del tipo ExcepcionDominioFuncion."	| argumento |	argumento := funcion evaluarEn: numero.	(argumento <= 0)ifTrue:	[		ExcepcionDominioFuncion new signal.	].	^((argumento) log: Float e).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionLogaritmoNatural class	instanceVariableNames: ''!!EstrategiaEvaluacionLogaritmoNatural class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/11/2010 17:15'!crearNueva: funcion	"Recibe una funcion. Crea una nueva instancia de la estrategia y le setea la funcion. Devuelve la estrategia."	^(super crearNueva: self conFuncion: funcion).! !EstrategiaEvaluacionDeDosFunciones subclass: #EstrategiaEvaluacionMultiplicacion	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionMultiplicacion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/10/2010 17:40'!setProductoUno: factorUno setProductoDos: factorDos	"Recibe dos funciones como parametros y las guarda en atributos."	super setFuncionUno: factorUno setFuncionDos: factorDos.! !!EstrategiaEvaluacionMultiplicacion methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/15/2010 19:54'!evaluarEn: numero	"Recibe un numero. Evalua ambas funciones (factores) guardadas y multiplica los resultados. Devuelve el valor obtenido."	^((funcionUno  evaluarEn: numero)*(funcionDos evaluarEn: numero))! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionMultiplicacion class	instanceVariableNames: ''!!EstrategiaEvaluacionMultiplicacion class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/10/2010 16:39'!crearNuevaCon: productoUno y: productoDos	"Crea una nueva estrategia. Recibe los dos producos que son funciones y los guarda."	|  estrategia |	estrategia := EstrategiaEvaluacionMultiplicacion new.	estrategia setProductoUno: productoUno setProductoDos: productoDos.	^estrategia! !EstrategiaEvaluacionDeDosFunciones subclass: #EstrategiaEvaluacionResta	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionResta methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/10/2010 19:15'!setFuncionInicial: funcionInicial setFuncionARestar: funcionARestar	"Recibe una funcion inicial y una funcion a restar y las guarda en atributos."	super setFuncionUno: funcionInicial setFuncionDos: funcionARestar! !!EstrategiaEvaluacionResta methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/15/2010 19:54'!evaluarEn: numero	"Recibe un numero y evaluar las dos funciones en ese valor. Devuelve el resultado."	^((funcionUno  evaluarEn: numero)-(funcionDos evaluarEn: numero)).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionResta class	instanceVariableNames: 'fInicial'!!EstrategiaEvaluacionResta class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/10/2010 16:03'!crearNuevaCon: funcionInicial y: funcionARestar 	"Recibe dos funciones. Crea una nueva instancia de la estrategia y guarda las funcion en atributos. La primera es la funcion inicial la segunda es la funcion a restar. Devuelve la estrategia."	|  estrategia |	estrategia := EstrategiaEvaluacionResta new.	estrategia setFuncionInicial: funcionInicial setFuncionARestar:funcionARestar.	^estrategia.! !EstrategiaEvaluacionDeUnaFuncion subclass: #EstrategiaEvaluacionSeno	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionSeno methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/15/2010 20:23'!evaluarEn: numero	"Recibe un numero y evalua la funcion en ese numero y luego calcula el seno. Devuelve el valor obtenido."	^((funcion evaluarEn: numero) sin)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionSeno class	instanceVariableNames: ''!!EstrategiaEvaluacionSeno class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/11/2010 17:15'!crearNueva: funcion	"Recibe una funcion. Crea una nueva instanci de la estrategia y le asigna la funcion. Devuelve la estrategia."	^(super crearNueva: self conFuncion: funcion).! !EstrategiaEvaluacionDeDosFunciones subclass: #EstrategiaEvaluacionSuma	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionSuma methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/15/2010 20:12'!setFuncionUno: fUno setFuncionDos: fDos	"Recibe como parametros dos funciones y las guarda en atributos."	funcionUno := fUno.	funcionDos  := fDos.! !!EstrategiaEvaluacionSuma methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/15/2010 19:54'!evaluarEn: numero	"Evalua la funcion en el valor recibido. Llama al metodo evaluar de las dos funciones que tiene la instancia."	^((funcionUno  evaluarEn: numero) +(funcionDos  evaluarEn: numero)). ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionSuma class	instanceVariableNames: ''!!EstrategiaEvaluacionSuma class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/10/2010 16:04'!crearNuevaCon: funcionUno y: funcionDos	"Recibe dos funciones. Crea una nueva instancia de la estrategia y asigna los valores de los atributos f1 = funcfuncionUno, f2 = funcionDos con los parametros recibidos. Devuelve la estrategia."	| estrategia |	estrategia := EstrategiaEvaluacionSuma new.	estrategia setFuncionUno: funcionUno setFuncionDos: funcionDos.	^estrategia.	! !EstrategiaEvaluacionDeUnaFuncion subclass: #EstrategiaEvaluacionTangente	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionTangente methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/15/2010 20:25'!evaluarEn: numero	"Recibe un numero y evalua la funcion en ese numero y luego calcula la tangente. Devuelve el valor obtenido."	| argumento |	argumento := (funcion evaluarEn: numero).	(((argumento \\ (Float pi / 2)) = 0) & ((argumento \\ (Float pi) ~= 0)))ifTrue:	[		ExcepcionDominioFuncion  new signal.	].	^(argumento tan)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionTangente class	instanceVariableNames: ''!!EstrategiaEvaluacionTangente class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/11/2010 17:15'!crearNueva: funcion	"Recibe una funcion. Crea una nueva instancia de la estrategia y le setea la funcion. Devuelve la estrategia."	^(super crearNueva: self conFuncion: funcion).! !EstrategiaEvaluacion subclass: #EstrategiaEvaluacionXALaN	instanceVariableNames: 'exponente'	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaEvaluacionXALaN methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/11/2010 20:01'!setExponente: numero	exponente := numero.! !!EstrategiaEvaluacionXALaN methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/15/2010 20:20'!evaluarEn: numero	"Recibe un numero. Eleva el numero al exponente. Devuelve el resultado."	^(numero raisedTo: (exponente))! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaEvaluacionXALaN class	instanceVariableNames: ''!!EstrategiaEvaluacionXALaN class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/11/2010 20:00'!crearConExponente: numero	"Recibe un numero. Crea una nueva instancia de la estrategia seteando como exponente al numero recibido. Devuelve la estrategia."	| estrategia |	estrategia := EstrategiaEvaluacionXALaN new.	estrategia setExponente: numero.	^estrategia.	! !Object subclass: #EstrategiaIntegracion	instanceVariableNames: 'subIntervalos'	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaIntegracion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 15:23'!setSubIntervalos: numero	"Deberia ser usado solo una vez en el momento de creacion."	(subIntervalos ~= nil)ifTrue:	[		Error new signal: 'No se puede volver a setear'.	].	subIntervalos := numero.! !!EstrategiaIntegracion methodsFor: 'Integracion' stamp: 'DamianSchenkelman 4/17/2010 17:32'!integrar: f entre: a y: b	"Devuelve la integral definida de la funcion recibida como parametro entre los valores a y b."	| sumatoria multiplicadorSentido inicial final fDeInicial fDeFinal |	"De la implementacion en Python de la regla de integraciontrapezoidal de http://en.wikipedia.org/wiki/Trapezoidal_rule"	(b < a)ifTrue:	[		inicial := b.		final := a.		multiplicadorSentido := -1.	]	ifFalse:	[		inicial := a.		final := b.		multiplicadorSentido := 1.		].	fDeInicial := f evaluarEn: inicial.	fDeFinal := f evaluarEn: final.	sumatoria := ExtensionesNumeros obtenerSumatoriaDe: ([:x|f evaluarEn: (inicial + ((final-inicial) * (x/subIntervalos)))]) desde: 1 hasta: subIntervalos.	^((final - inicial) * (fDeInicial*0.5 + fDeFinal*0.5 + sumatoria) / subIntervalos) * multiplicadorSentido.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaIntegracion class	instanceVariableNames: ''!!EstrategiaIntegracion class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/17/2010 14:38'!crearNueva	"Crea una nueva estrategia de integracion y la devuelve."	| estrategia |	estrategia := EstrategiaIntegracion new.	estrategia setSubIntervalos:30000.	^estrategia.! !Object subclass: #EstrategiaMaximosYMinimos	instanceVariableNames: 'intervalo'	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EstrategiaMaximosYMinimos methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/18/2010 10:48'!obtenerMaximoDe: funcion desde: inicial hasta: final	"Devuelve el maximo valor en el intervalo inicial a final."	| resultados resultado punto |	(ExtensionesNumeros esCrecienteYNoVacioDesde: inicial hasta: final cada: intervalo)ifFalse:		[		ExcepcionEvaluacionIntervalo new signal.	].	^self obtenerExtremoDe: funcion desde: inicial hasta:final  bloqueComparacion: [:p :y| p getY < y]	! !!EstrategiaMaximosYMinimos methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/18/2010 10:48'!obtenerMinimoDe: funcion desde: inicial hasta: final	"Devuelve el minimo valor en el intervalo inicial a final."	| resultados resultado punto |	(ExtensionesNumeros esCrecienteYNoVacioDesde: inicial hasta: final cada: intervalo)ifFalse:		[		ExcepcionEvaluacionIntervalo new signal.	].	^self obtenerExtremoDe: funcion desde: inicial hasta:final  bloqueComparacion: [:p :y| p getY > y]! !!EstrategiaMaximosYMinimos methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 16:41'!setIntervaloEvaluacion: numero	intervalo := numero! !!EstrategiaMaximosYMinimos methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 17:57'!obtenerExtremoDe: funcion desde: inicial hasta:final bloqueComparacion: bloque	"Obtiene un extremo de la funcion en el intervalo inicial a final usando el bloque de comparacion para determinar si se alcanzo un nuevo extremo."	| resultados resultado punto y |	punto := Punto new.	punto setX: inicial.	punto setY: (funcion evaluarEn: inicial).	inicial to: final by: intervalo do:	[:x|		y := funcion evaluarEn: x.		(bloque value: punto value:y)ifTrue:		[			punto setY: y.			punto setX: x.		]	].	^punto. ! !EstrategiaMaximosYMinimos subclass: #EstrategiaMaximosYMinimosContinuos	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaMaximosYMinimosContinuos class	instanceVariableNames: 'estrategia'!!EstrategiaMaximosYMinimosContinuos class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/17/2010 16:49'!crearNueva	"Crea una nueva estrategia y la devuelve."	estrategia := EstrategiaMaximosYMinimosContinuos new.	estrategia setIntervaloEvaluacion: 0.0001.	^estrategia! !EstrategiaMaximosYMinimos subclass: #EstrategiaMaximosYMinimosDiscretos	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EstrategiaMaximosYMinimosDiscretos class	instanceVariableNames: ''!!EstrategiaMaximosYMinimosDiscretos class methodsFor: 'as yet unclassified' stamp: 'DamianSchenkelman 4/17/2010 17:40'!crearNueva	"Crea una nueva estrategia y la devuelve."	| estrategia |	estrategia := EstrategiaMaximosYMinimosDiscretos new.	estrategia setIntervaloEvaluacion: 1.	^estrategia! !Object subclass: #EvaluadorInterseccionFuncionesContinuas	instanceVariableNames: 'subIntervalos'	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!EvaluadorInterseccionFuncionesContinuas methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/18/2010 10:22'!setSubIntervalos: numero	subIntervalos := numero.! !!EvaluadorInterseccionFuncionesContinuas methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/18/2010 10:48'!obtenerInterseccionDe: f y: g  desde: inicial hasta: final	"Recibe dos funciones f y g. Calcula los puntos de interseccion en el intervalo [inicial;final] y los devuelve en una coleccion de puntos."	| paso puntos fDeX gDeX punto |	paso := (final - inicial) abs / subIntervalos.	(ExtensionesNumeros esCrecienteYNoVacioDesde: inicial  hasta: final  cada: paso)ifFalse:	[		ExcepcionEvaluacionIntervalo new signal.	].	puntos := OrderedCollection new.	inicial to: final by: paso do: 	[		:x|		fDeX := f evaluarEn: x.		gDeX := g evaluarEn: x.		(fDeX closeTo: gDeX)ifTrue:		[			punto := Punto new.			punto setX: x.			punto setY: fDeX.			puntos add: punto.		].	].	^puntos.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EvaluadorInterseccionFuncionesContinuas class	instanceVariableNames: ''!!EvaluadorInterseccionFuncionesContinuas class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 11:03'!crearNuevo 	"Crea un nuevo evaluador de interseccion de funciones y lo devuelve."	| evaluador |	evaluador := EvaluadorInterseccionFuncionesContinuas new.	evaluador setSubIntervalos: 100000.	^evaluador.! !Error subclass: #ExcepcionArgumentoInvalido	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!ArithmeticError subclass: #ExcepcionDominioFuncion	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!ArithmeticError subclass: #ExcepcionEvaluacionIntervalo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!ArithmeticError subclass: #ExcepcionOperacionAritmeticaInvalida	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!Object subclass: #ExtensionesNumeros	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ExtensionesNumeros class	instanceVariableNames: ''!!ExtensionesNumeros class methodsFor: 'Conjuntos' stamp: 'DamianSchenkelman 4/13/2010 00:06'!esNatural: numero	"Recibe un numero y devuelve True si es natural o cero y false en caso contrario."	^((numero > 0) & (numero - (numero asInteger) = 0))! !!ExtensionesNumeros class methodsFor: 'Conjuntos' stamp: 'DamianSchenkelman 4/13/2010 00:07'!esNaturalOCero: numero	"Recibe un numero y devuelve True si es natural o cero y false en caso contrario."	^((ExtensionesNumeros esNatural: numero) | (numero = 0))! !!ExtensionesNumeros class methodsFor: 'Operaciones' stamp: 'DamianSchenkelman 4/17/2010 16:14'!obtenerSumatoriaDe: expresion desde: inicial hasta: final	"Recibe una expresion. Devuelve la sumatoria desde el valor inicial al final de la expresion."	| sumatoria auxiliar |	sumatoria := 0.	inicial to: final by: 1 do: 	[		:x|		auxiliar := expresion value: x.		sumatoria := sumatoria + auxiliar.	].	^sumatoria! !!ExtensionesNumeros class methodsFor: 'Intervalos' stamp: 'DamianSchenkelman 4/18/2010 10:47'!esCrecienteYNoVacioDesde: inicial hasta: final cada: intervalo	"Recibe un valor inicial, uno final y un intervalo. Devuelve false si el intervalo es menor a cero, si el valor inicial es mayor o igual al final o s¡ la diferencia entre el valor final e inicial es menor al intervalo. Devuelve true en caso contrario."	(intervalo <= 0)ifTrue:[^false].	(inicial >= final)ifTrue:[^false].	((final - inicial) < intervalo)ifTrue:[^false.].	^true.! !Object subclass: #FabricaFunciones	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 11:54'!crearArcoCoseno: funcion	"Recibe una funcion. Crea una nueva funcion ArcoCoseno con la funcion de argumento y la devuelve."	^self crearFuncionConEstrategiaEvaluacion: EstrategiaEvaluacionArcoCoseno estrategiaEvaluacionIntervalos: EstrategiaEvaluacionIntervaloContinuo new estrategiaDerivacion: EstrategiaDerivacion new estrategiaIntegracion:  EstrategiaIntegracion new estrategiaExtremos: EstrategiaMaximosYMinimosContinuos new funcion: funcion! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 11:54'!crearArcoSeno: funcion	"Recibe una funcion. Crea una nueva funcion ArcoSeno con la funcion de argumento y la devuelve."	^self crearFuncionConEstrategiaEvaluacion: EstrategiaEvaluacionArcoSeno estrategiaEvaluacionIntervalos: EstrategiaEvaluacionIntervaloContinuo new estrategiaDerivacion: EstrategiaDerivacion new estrategiaIntegracion:  EstrategiaIntegracion new estrategiaExtremos: EstrategiaMaximosYMinimosContinuos new funcion: funcion! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 11:53'!crearConstante: numero	"Recibe un numero. Crea una nueva funcion con ese numero como constante. Si el parametro recibido no es un numero lanza una excepcion ExcepcionArgumentoInvalido."	| estrategiaEvaluacion funcion |	(numero isKindOf: Number)ifFalse:	[		ExcepcionArgumentoInvalido new signal.	].	estrategiaEvaluacion := EstrategiaEvaluacionConstantes crearNueva: numero.	funcion := Funcion crearConEstrategiaEvaluacion: estrategiaEvaluacion estrategiaEvaluacionIntervalos: EstrategiaEvaluacionIntervaloContinuo new estrategiaDerivacion: EstrategiaDerivacion  new  estrategiaIntegracion: EstrategiaIntegracion new estrategiaExtremos: EstrategiaMaximosYMinimosContinuos new.	^funcion! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 11:54'!crearCoseno: funcion	"Recibe una funcion. Crea una nueva funcion Coseno con la funcion de argumento y la devuelve."	^self crearFuncionConEstrategiaEvaluacion: EstrategiaEvaluacionCoseno estrategiaEvaluacionIntervalos: EstrategiaEvaluacionIntervaloContinuo new estrategiaDerivacion: EstrategiaDerivacion new estrategiaIntegracion:  EstrategiaIntegracion new estrategiaExtremos: EstrategiaMaximosYMinimosContinuos new funcion: funcion! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 11:55'!crearDivision: funcionUno y: funcionDos	"Recibe dos funciones. Crea una nueva funcion representando el cociente de funcionUno sobre funfuncionDos. Devuelve la funcion."	^self crearFuncionConEstrategiaEvaluacion: EstrategiaEvaluacionDivision estrategiaEvaluacionIntervalos: EstrategiaEvaluacionIntervaloContinuo new estrategiaDerivacion: EstrategiaDerivacion new estrategiaIntegracion:  EstrategiaIntegracion new estrategiaExtremos: EstrategiaMaximosYMinimosContinuos new funcionUno: funcionUno funcionDos: funcionDos! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 11:56'!crearExponencial: funcionUno y: funcionDos	"Recibe dos funciones. Crea una nueva funcion representando funcionUno elevado a funcionDos. Devuelve la funcion."	^self crearFuncionConEstrategiaEvaluacion: EstrategiaEvaluacionExponencial estrategiaEvaluacionIntervalos: EstrategiaEvaluacionIntervaloContinuo new estrategiaDerivacion: EstrategiaDerivacion new estrategiaIntegracion:  EstrategiaIntegracion new estrategiaExtremos: EstrategiaMaximosYMinimosContinuos new funcionUno: funcionUno funcionDos: funcionDos! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 11:58'!crearFactorial: funcion	"Recibe una funcion. Crea una nueva funcion representando el factorial de la funcion recibida como parametro. Devuelve la funcion nueva."	^self crearFuncionConEstrategiaEvaluacion: EstrategiaEvaluacionFactorial estrategiaEvaluacionIntervalos: EstrategiaEvaluacionIntervaloDiscreto new estrategiaDerivacion: nil estrategiaIntegracion: nil estrategiaExtremos: EstrategiaMaximosYMinimosDiscretos new funcion: funcion! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 11:59'!crearFibonacci: funcion	"Recibe una funcion. Crea una nueva funcion representando el numero de la serie de fibonacci de la funcion recibida como parametro. Devuelve la funcion nueva."	^self crearFuncionConEstrategiaEvaluacion: EstrategiaEvaluacionFibonacci estrategiaEvaluacionIntervalos: EstrategiaEvaluacionIntervaloDiscreto new estrategiaDerivacion: nil estrategiaIntegracion: nil estrategiaExtremos: EstrategiaMaximosYMinimosDiscretos new funcion: funcion! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 11:48'!crearFuncionConEstrategiaEvaluacion: estrategiaEvaluacion estrategiaEvaluacionIntervalos: estrategiaIntervalos estrategiaDerivacion: estrategiaDerivacion estrategiaIntegracion: estrategiaIntegracion estrategiaExtremos: estrategiaExtremos funcion: funcion 	"Recibe un tipo de estrategia de evaluacion, una estrategia de evaluacion de intervalos, una de derivacion, una de integracion, una de extremos y dos funciones. Crea una funcion con las estrategias de evaluacion y usa las funciones para crear la estrategia de evaluacion."	| estEvaluacion |	estEvaluacion := estrategiaEvaluacion crearNueva: funcion.	^(Funcion crearConEstrategiaEvaluacion: estEvaluacion estrategiaEvaluacionIntervalos: estrategiaIntervalos estrategiaDerivacion: estrategiaDerivacion estrategiaIntegracion: estrategiaIntegracion estrategiaExtremos: estrategiaExtremos)! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 11:47'!crearFuncionConEstrategiaEvaluacion: estrategiaEvaluacion estrategiaEvaluacionIntervalos: estrategiaIntervalos estrategiaDerivacion: estrategiaDerivacion estrategiaIntegracion: estrategiaIntegracion estrategiaExtremos: estrategiaExtremos funcionUno: funcionUno  funcionDos: funcionDos 	"Recibe un tipo de estrategia de evaluacion, una estrategia de evaluacion de intervalos, una de derivacion, una de integracion, una de extremos y dos funciones. Crea una funcion con las estrategias de evaluacion y usa las funciones para crear la estrategia de evaluacion."	| funcion estEvaluacion |	estEvaluacion := estrategiaEvaluacion crearNuevaCon: funcionUno y: funcionDos.	^(Funcion crearConEstrategiaEvaluacion: estEvaluacion estrategiaEvaluacionIntervalos: estrategiaIntervalos estrategiaDerivacion: estrategiaDerivacion estrategiaIntegracion: estrategiaIntegracion estrategiaExtremos: estrategiaExtremos)! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 12:00'!crearLogaritmoNatural: funcion	"Recibe una funcion. Crea una nueva funcion representando el logaritmo de la funcion recibida como parametro como argumento. Devuelve la funcion nueva."	^self crearFuncionConEstrategiaEvaluacion: EstrategiaEvaluacionLogaritmoNatural estrategiaEvaluacionIntervalos: EstrategiaEvaluacionIntervaloContinuo new estrategiaDerivacion: EstrategiaDerivacion new estrategiaIntegracion: EstrategiaIntegracion new estrategiaExtremos: EstrategiaMaximosYMinimosContinuos new funcion: funcion! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 11:44'!crearMultiplicacion: funcionUno y: funcionDos	"Recibe dos funciones. Crea una nueva representando el producto de ambas y la devuelve."	^self crearFuncionConEstrategiaEvaluacion: EstrategiaEvaluacionMultiplicacion estrategiaEvaluacionIntervalos: EstrategiaEvaluacionIntervaloContinuo new estrategiaDerivacion: EstrategiaDerivacion new estrategiaIntegracion:  EstrategiaIntegracion new estrategiaExtremos: EstrategiaMaximosYMinimosContinuos new funcionUno: funcionUno funcionDos: funcionDos! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 11:44'!crearResta: funcionUno y: funcionDos	"Recibe dos funciones. Crea una nueva funcion representando la resta de la primera menos la segunda y la devuelve."	^self crearFuncionConEstrategiaEvaluacion: EstrategiaEvaluacionResta estrategiaEvaluacionIntervalos: EstrategiaEvaluacionIntervaloContinuo new estrategiaDerivacion: EstrategiaDerivacion new estrategiaIntegracion:  EstrategiaIntegracion new estrategiaExtremos: EstrategiaMaximosYMinimosContinuos new funcionUno: funcionUno funcionDos: funcionDos! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 12:01'!crearSeno: funcion	"Recibe una funcion. Crea una nueva funcion Seno con la funcion de argumento y la devuelve."	^self crearFuncionConEstrategiaEvaluacion: EstrategiaEvaluacionSeno estrategiaEvaluacionIntervalos: EstrategiaEvaluacionIntervaloContinuo new estrategiaDerivacion: EstrategiaDerivacion new estrategiaIntegracion:  EstrategiaIntegracion new estrategiaExtremos: EstrategiaMaximosYMinimosContinuos new funcion: funcion! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 11:44'!crearSuma: funcionUno y: funcionDos	"Recibe dos funciones. Crea una nueva funcion representando la suma de ambas y la devuelve."	^self crearFuncionConEstrategiaEvaluacion: EstrategiaEvaluacionSuma estrategiaEvaluacionIntervalos: EstrategiaEvaluacionIntervaloContinuo new estrategiaDerivacion: EstrategiaDerivacion new estrategiaIntegracion:  EstrategiaIntegracion new estrategiaExtremos: EstrategiaMaximosYMinimosContinuos new funcionUno: funcionUno funcionDos: funcionDos	! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 12:02'!crearTangente: funcion	"Recibe una funcion. Crea una nueva funcion Tangente con la funcion de argumento y la devuelve."	^self crearFuncionConEstrategiaEvaluacion: EstrategiaEvaluacionTangente estrategiaEvaluacionIntervalos: EstrategiaEvaluacionIntervaloContinuo new estrategiaDerivacion: EstrategiaDerivacion new estrategiaIntegracion:  EstrategiaIntegracion new estrategiaExtremos: EstrategiaMaximosYMinimosContinuos new funcion: funcion! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/11/2010 20:25'!crearTerminoPolinomialConMultiplicador: multiplicador exponente: exponente	"Recibe un multiplicador y un exponente. Crea una multiplicacion entre una constante con el multiplicador y un termino X a la N con el exponente y la devuelve."	^(self crearMultiplicacion: (self crearConstante: multiplicador)  y: (self crearXALaNConExponente: exponente)).! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/11/2010 20:52'!crearX 	"Crea un termino polinomial con multiplicador 1 y exponente 1 (es decir x) y lo devuelve."	^(self crearTerminoPolinomialConMultiplicador: 1 exponente: 1).! !!FabricaFunciones methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 12:05'!crearXALaNConExponente: numero	"Recibe un numero. Crea una funcion representando X elevado a la N y la devuelve."	| estrategia funcion |	(numero isKindOf: Number)ifFalse:	[		ExcepcionArgumentoInvalido new signal.	].	estrategia := EstrategiaEvaluacionXALaN crearConExponente: numero.	funcion := Funcion crearConEstrategiaEvaluacion: estrategia estrategiaEvaluacionIntervalos: EstrategiaEvaluacionIntervaloContinuo new estrategiaDerivacion: EstrategiaDerivacion new estrategiaIntegracion: EstrategiaIntegracion new estrategiaExtremos: EstrategiaMaximosYMinimosContinuos new.	^funcion! !Object subclass: #Funcion	instanceVariableNames: 'estrategiaEvaluacion estrategiaEvaluacionIntervalos estrategiaDerivacion estrategiaIntegracion estrategiaExtremos'	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!Funcion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 13:19'!setEstrategiaDerivacion: estrategia	(estrategiaDerivacion ~=  nil)ifTrue:	[		Error new signal: 'No se puede volver a setear'.	].	estrategiaDerivacion := estrategia.! !!Funcion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 12:13'!setEstrategiaEvaluacion: estrategia	(estrategiaEvaluacion ~=  nil)ifTrue:	[		Error new signal: 'No se puede volver a setear'.	].	estrategiaEvaluacion := estrategia.! !!Funcion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 12:13'!setEstrategiaEvaluacionIntervalos: estrategiaIntervalos	(estrategiaEvaluacionIntervalos ~=  nil)ifTrue:	[		Error new signal: 'No se puede volver a setear'.	].	estrategiaEvaluacionIntervalos := estrategiaIntervalos! !!Funcion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 18:16'!setEstrategiaExtremos: estrategia	(estrategiaExtremos ~=  nil)ifTrue:	[		Error new signal: 'No se puede volver a setear'.	].	estrategiaExtremos := estrategia.! !!Funcion methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 15:37'!setEstrategiaIntegracion: estrategia	(estrategiaIntegracion ~=  nil)ifTrue:	[		Error new signal: 'No se puede volver a setear'.	].	estrategiaIntegracion := estrategia.! !!Funcion methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/11/2010 21:26'!componerCon: funcion evaluarEn: numero	"Recibe una funcion y un numero. Evalua la funcion en ese numero. Evalua la funcion actual en el resultado. Devuelve el resultado final."	| resultado |	resultado :=	funcion evaluarEn: numero.	^self evaluarEn: resultado.! !!Funcion methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/12/2010 23:49'!evaluarDesde: inicial hasta: final cada: intervalo	"Recibe un valor inical uno final y un intervalo. Devuelve "	(estrategiaEvaluacionIntervalos puedeEvaluarDesde: inicial hasta: final  cada: intervalo)ifFalse: 	[		^ExcepcionEvaluacionIntervalo new signal.	].	^estrategiaEvaluacionIntervalos evaluar: self desde: inicial  hasta: final  cada: intervalo.! !!Funcion methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/15/2010 20:40'!evaluarEn: numero	"Recibe un numero. Llama a la estrategia de evaluacion para que evalue en ese numero."	^estrategiaEvaluacion evaluarEn: numero.! !!Funcion methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/17/2010 18:23'!obtenerMaximoEntre: inicial y: final	"Obtiene el punto maximo de la funcion entre el intervalo inicial y final."	^estrategiaExtremos obtenerMaximoDe: self desde: inicial hasta: final.! !!Funcion methodsFor: 'Evaluacion' stamp: 'DamianSchenkelman 4/18/2010 10:06'!obtenerMinimoEntre: inicial y: final	"Obtiene el punto maximo de la funcion entre el intervalo inicial y final."	^estrategiaExtremos obtenerMinimoDe: self desde: inicial hasta: final.! !!Funcion methodsFor: 'Derivacion' stamp: 'DamianSchenkelman 4/17/2010 12:56'!derivarEn: numero	"Recibe un numero. Devuelve la derivada numerica de la funcion en el numero. Si la funcion no es derivable lanza una excepcion del tipo ExcepcionOperacionAritmeticaInvalida."	(estrategiaDerivacion == nil)ifTrue:	[		ExcepcionOperacionAritmeticaInvalida new signal.	].	^estrategiaDerivacion derivarEn: numero.! !!Funcion methodsFor: 'Integracion' stamp: 'DamianSchenkelman 4/17/2010 15:49'!integrarEntre: inicial y: final	"Devuelve la integral definida de la funcion entre el valor inicial y final."	^estrategiaIntegracion integrar: self entre: inicial  y: final.! !!Funcion methodsFor: 'Operaciones' stamp: 'DamianSchenkelman 4/18/2010 11:26'!* unaFuncion	"Recibe una funcion y devuelve una nueva funcion representando el producto de la actual y la recibida. Se puede hacer de otra forma, pero es una suerte de azucar sintactico."	^((FabricaFunciones new) crearMultiplicacion: self y: unaFuncion).! !!Funcion methodsFor: 'Operaciones' stamp: 'DamianSchenkelman 4/18/2010 11:20'!+ unaFuncion	"Recibe una funcion y devuelve una nueva funcion representando la suma de la actual y la recibida. Se puede hacer de otra forma, pero es una suerte de azucar sintactico."	^((FabricaFunciones new) crearSuma: self y: unaFuncion).! !!Funcion methodsFor: 'Operaciones' stamp: 'DamianSchenkelman 4/18/2010 11:23'!- unaFuncion	"Recibe una funcion y devuelve una nueva funcion representando la resta de la actual menos la recibida. Se puede hacer de otra forma, pero es una suerte de azucar sintactico."	^((FabricaFunciones new) crearResta: self y: unaFuncion).! !!Funcion methodsFor: 'Operaciones' stamp: 'DamianSchenkelman 4/18/2010 11:30'!/ unaFuncion	"Recibe una funcion y devuelve una nueva funcion representando el cociente de la actual sobre la recibida. Se puede hacer de otra forma, pero es una suerte de azucar sintactico."	^((FabricaFunciones new) crearDivision: self y: unaFuncion).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Funcion class	instanceVariableNames: ''!!Funcion class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/11/2010 17:57'!crearConEstrategiaEvaluacion: estrategia	"Recibe una estrategia de evaluacion. Crea una funcion y le setea esta estrategia de evaluacion. Devuelve la funcion."	| funcion |	funcion := self new.	funcion setEstrategiaEvaluacion: estrategia.	^funcion! !!Funcion class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/12/2010 23:15'!crearConEstrategiaEvaluacion: estrategiaEvaluacion estrategiaEvaluacionIntervalos: estrategiaIntervalos	"Recibe una estrategia de evaluaciony una de evaluacion de intervalos. Crea una funcion con ambas estrategias y la devuelve."	| funcion |	funcion := Funcion crearConEstrategiaEvaluacion: estrategiaEvaluacion.	funcion setEstrategiaEvaluacionIntervalos: estrategiaIntervalos.	^funcion.! !!Funcion class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/17/2010 15:37'!crearConEstrategiaEvaluacion: estrategiaEvaluacion estrategiaEvaluacionIntervalos: estrategiaIntervalos estrategiaDerivacion: estrategiaDerivacion estrategiaIntegracion: estrategiaIntegracion	"Recibe una estrategia de evaluacion, una de evaluacion de intervalos, una de derivacion y una de integracion. Crea una funcion con las estrategias y la devuelve."	| funcion |	funcion := Funcion crearConEstrategiaEvaluacion: estrategiaEvaluacion estrategiaEvaluacionIntervalos: estrategiaIntervalos.	funcion setEstrategiaDerivacion: estrategiaDerivacion.	funcion setEstrategiaIntegracion: estrategiaIntegracion.	^funcion.! !!Funcion class methodsFor: 'Creacion' stamp: 'DamianSchenkelman 4/18/2010 11:35'!crearConEstrategiaEvaluacion: estrategiaEvaluacion estrategiaEvaluacionIntervalos: estrategiaIntervalos estrategiaDerivacion: estrategiaDerivacion estrategiaIntegracion: estrategiaIntegracion estrategiaExtremos: estrategiaExtremos	"Recibe una estrategia de evaluacion, una de evaluacion de intervalos, una de derivacion, una de integracion y una de evaluacion extremos. Crea una funcion con las estrategias y la devuelve."	| funcion |	funcion := self new.	funcion setEstrategiaEvaluacion: estrategiaEvaluacion.	funcion setEstrategiaEvaluacionIntervalos: estrategiaIntervalos.	funcion setEstrategiaDerivacion: estrategiaDerivacion.	funcion setEstrategiaIntegracion: estrategiaIntegracion.	funcion setEstrategiaExtremos: estrategiaExtremos.	^funcion.! !Object subclass: #Punto	instanceVariableNames: 'x y'	classVariableNames: ''	poolDictionaries: ''	category: 'TP190728'!!Punto methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 16:37'!getX	^x! !!Punto methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 16:37'!getY	 ^y! !!Punto methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 16:36'!setX: valor	x := valor.! !!Punto methodsFor: 'Propiedades' stamp: 'DamianSchenkelman 4/17/2010 16:37'!setY: valor	y:= valor! !